<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>odl.space package &mdash; odl beta documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     'beta',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="odl beta documentation" href="index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="odl-space-package">
<h1>odl.space package<a class="headerlink" href="#odl-space-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-odl.space.cartesian">
<span id="odl-space-cartesian-module"></span><h2>odl.space.cartesian module<a class="headerlink" href="#module-odl.space.cartesian" title="Permalink to this headline">¶</a></h2>
<p>CPU implementations of <cite>n</cite>-dimensional Cartesian spaces.</p>
<p>This is a default implementation of <img class="math" src="_images/math/49b8662a7233adc84551ec493568becdccbafac6.png" alt="A^n"/> for an arbitrary set
<img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> as well as the real and complex spaces <img class="math" src="_images/math/4b2f86413eb03ebbcc1b0ffd8f4669fa28e3575b.png" alt="R^n"/> and
<img class="math" src="_images/math/2383a69a5b4b04f7d62a0b0cf16d18f5ea55bb0e.png" alt="C^n"/>. The latter two each come in a basic version with vector
multiplication only and as metric, normed, Hilbert and Euclidean space
variants. The data is represented by NumPy arrays.</p>
<div class="section" id="list-of-classes">
<h3>List of classes<a class="headerlink" href="#list-of-classes" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="21%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Class name</th>
<th class="head">Direct
Ancestors</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>Ntuples</cite></td>
<td><cite>Set</cite></td>
<td>Basic class of <cite>n</cite>-tuples where each
entry is of the same type</td>
</tr>
<tr class="row-odd"><td><cite>Fn</cite></td>
<td><cite>EuclideanCn</cite></td>
<td><cite>HilbertRn</cite> with the standard inner
(dot) product</td>
</tr>
<tr class="row-even"><td><cite>Cn</cite></td>
<td><cite>Ntuples</cite>,
<cite>Algebra</cite></td>
<td><cite>n</cite>-tuples of complex numbers with
vector-vector multiplication</td>
</tr>
<tr class="row-odd"><td><cite>Rn</cite></td>
<td><cite>Cn</cite></td>
<td><cite>n</cite>-tuples of real numbers with
vector-vector multiplication</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="space-attributes-and-methods">
<h3>Space attributes and methods<a class="headerlink" href="#space-attributes-and-methods" title="Permalink to this headline">¶</a></h3>
<p>The following tables summarize all attributes and methods of spaces in
this module. Each table reflects the <em>added</em> features for the
respective class.</p>
<p><strong>`Ntuples` and subclasses:</strong></p>
<p>Attributes:</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="20%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>dim</cite></td>
<td><cite>int</cite></td>
<td>The number of entries per tuple</td>
</tr>
<tr class="row-odd"><td><cite>dtype</cite></td>
<td><cite>type</cite></td>
<td>The data dype of each tuple entry</td>
</tr>
</tbody>
</table>
<p>Methods:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="22%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Signature</th>
<th class="head">Return type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>contains(other)</cite></td>
<td><cite>bool</cite></td>
<td>Test if <cite>other</cite> is an element of
this space.</td>
</tr>
<tr class="row-odd"><td><cite>element
(inp=None)</cite></td>
<td><cite>&lt;space
type&gt;.Vector</cite></td>
<td>Create a space element. If <cite>inp</cite> is
<cite>None</cite>, merely memory is allocated.
Otherwise, the element is created
from <cite>inp</cite>.</td>
</tr>
<tr class="row-even"><td><cite>equals (other)</cite></td>
<td><cite>bool</cite></td>
<td>Create a space element. If <cite>inp</cite> is
<cite>None</cite>, merely memory is allocated.
Otherwise, the element is created
from <cite>inp</cite>.</td>
</tr>
</tbody>
</table>
<p>Magic methods:</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="31%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Signature</th>
<th class="head">Provides syntax</th>
<th class="head">Implementation</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>s.__eq__(other)</cite></td>
<td><cite>s == other</cite></td>
<td><cite>equals(other)</cite></td>
</tr>
<tr class="row-odd"><td><cite>s.__ne__(other)</cite></td>
<td><cite>s != other</cite></td>
<td><cite>not equals(other)</cite></td>
</tr>
<tr class="row-even"><td><cite>s.__contains__(other)</cite></td>
<td><cite>other in s</cite></td>
<td><cite>contains(other)</cite></td>
</tr>
</tbody>
</table>
<p><strong>`Rn`/`Cn` and subclasses:</strong></p>
<p>Attributes:</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="24%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>field</cite></td>
<td><cite>RealNumbers</cite> or
<cite>ComplexNumbers</cite></td>
<td>The field over which the space is
defined</td>
</tr>
</tbody>
</table>
<p>Methods:</p>
</div>
<div class="section" id="vector-attributes-and-methods">
<h3>Vector attributes and methods<a class="headerlink" href="#vector-attributes-and-methods" title="Permalink to this headline">¶</a></h3>
<p>Similarly, the following tables incrementally summarize all attributes
and methods of vectors in this module.</p>
<p><strong>`Ntuples.Vector` and subclasses:</strong></p>
<p>Attributes:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="25%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>data</cite></td>
<td><cite>numpy.ndarray</cite></td>
<td>The container for the vector
entries</td>
</tr>
<tr class="row-odd"><td><cite>data_ptr</cite></td>
<td><cite>int</cite></td>
<td>A raw memory pointer to the data
container. Can be processed with
the <cite>ctypes</cite> module in Python.</td>
</tr>
<tr class="row-even"><td><cite>space</cite></td>
<td><cite>Set</cite></td>
<td>The space to which this vector
belongs</td>
</tr>
</tbody>
</table>
<p>Methods:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="22%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Signature</th>
<th class="head">Return type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>equals(other)</cite></td>
<td><cite>bool</cite></td>
<td>Test if <cite>other</cite> is equal to this
vector.</td>
</tr>
<tr class="row-odd"><td><cite>assign(other)</cite></td>
<td><cite>None</cite></td>
<td>Copy the values of <cite>other</cite> to this
vector.</td>
</tr>
<tr class="row-even"><td><cite>copy()</cite></td>
<td><cite>&lt;space
type&gt;.Vector</cite></td>
<td>Create a (deep) copy of this
vector.</td>
</tr>
</tbody>
</table>
<p>Magic methods:</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="31%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Signature</th>
<th class="head">Provides syntax</th>
<th class="head">Implementation</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>v.__eq__(other)</cite></td>
<td><cite>v == other</cite></td>
<td><cite>equals(other)</cite></td>
</tr>
<tr class="row-odd"><td><cite>v.__ne__(other)</cite></td>
<td><cite>v != other</cite></td>
<td><cite>not equals(other)</cite></td>
</tr>
<tr class="row-even"><td><cite>v.__getitem__(indices)</cite></td>
<td><cite>v[indices]</cite></td>
<td>by NumPy&#8217;s
<cite>__getitem__</cite> method</td>
</tr>
<tr class="row-odd"><td><cite>v.__setitem__(indices,
values)</cite></td>
<td><cite>v[indices] = values</cite></td>
<td>by NumPy&#8217;s
<cite>__setitem__</cite> method</td>
</tr>
</tbody>
</table>
<p><strong>`Rn.Vector`/`Cn.Vector` and subclasses:</strong></p>
<p>Attributes:</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="24%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>real</cite></td>
<td><cite>Rn.Vector</cite></td>
<td>Real part of this vector as view
(modifications affect the original
vector)</td>
</tr>
<tr class="row-odd"><td><cite>imag</cite></td>
<td><cite>Rn.Vector</cite></td>
<td>Imaginary part of this vector as view
(modifications affect the original
vector)</td>
</tr>
</tbody>
</table>
<p>Methods:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="22%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Signature</th>
<th class="head">Return type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>set_zero()</cite></td>
<td><cite>None</cite></td>
<td>Set this vector&#8217;s values to zero</td>
</tr>
</tbody>
</table>
<p>Magic methods:</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="9%" />
<col width="12%" />
<col width="18%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" colspan="2">Signature</th>
<th class="head" colspan="2">Provides syntax</th>
<th class="head">Implementation</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td colspan="2"><cite>v.__add__(other)</cite></td>
<td colspan="2"><cite>v + other</cite></td>
<td><cite>x = element()</cite>;
<cite>lincomb(x, 1, v, 1,
other)</cite></td>
</tr>
<tr class="row-odd"><td colspan="2"><cite>v.__sub__(other)</cite></td>
<td colspan="2"><cite>v - other</cite></td>
<td><cite>x = element()</cite>;
<cite>lincomb(x, 1, v, -1,
other)</cite></td>
</tr>
<tr class="row-even"><td colspan="2"><cite>v.__mul__(other)</cite></td>
<td colspan="2"><cite>v * other</cite></td>
<td><cite>x = element()</cite>;
<cite>lincomb(x, other, v)</cite>
<strong>or</strong>
<cite>x = v.copy();
multiply(other, x)</cite></td>
</tr>
<tr class="row-odd"><td colspan="2"><cite>v.__rmul__(other)</cite></td>
<td colspan="2"><cite>other * v</cite></td>
<td><cite>__mul__(other)</cite></td>
</tr>
<tr class="row-even"><td colspan="2"><cite>v.__truediv__(other)</cite></td>
<td colspan="2"><cite>v / other</cite></td>
<td><cite>__mul__(1.0/other)</cite></td>
</tr>
<tr class="row-odd"><td colspan="2"><cite>v.__div__(other)</cite></td>
<td colspan="2"><cite>v / other</cite></td>
<td>same as <cite>__truediv__</cite></td>
</tr>
<tr class="row-even"><td colspan="2"><cite>v.__iadd__(other)</cite></td>
<td colspan="2"><cite>v += other</cite></td>
<td><cite>lincomb(v, 1, v, 1,
other)</cite></td>
</tr>
<tr class="row-odd"><td colspan="2"><cite>v.__isub__(other)</cite></td>
<td colspan="2"><cite>v -= other</cite></td>
<td><cite>lincomb(v, 1, v, -1,
other)</cite></td>
</tr>
<tr class="row-even"><td colspan="2"><cite>v.__imul__(other)</cite></td>
<td colspan="2"><cite>v *= other</cite></td>
<td><cite>lincomb(v, other, v)</cite>
<strong>or</strong>
<cite>multiply(other, v)</cite></td>
</tr>
<tr class="row-odd"><td colspan="2"><cite>v.__itruediv__(other)</cite></td>
<td colspan="2"><cite>v /= other</cite></td>
<td><cite>__imul__(1.0/other)</cite></td>
</tr>
<tr class="row-even"><td colspan="2"><cite>v.__idiv__(other)</cite></td>
<td colspan="2"><cite>v /= other</cite></td>
<td>same as <cite>__itruediv__</cite></td>
</tr>
<tr class="row-odd"><td colspan="2"><cite>v.__pos__()</cite></td>
<td colspan="2"><cite>+v</cite></td>
<td><cite>copy()</cite></td>
</tr>
<tr class="row-even"><td colspan="2"><cite>v.__neg__()</cite></td>
<td colspan="2"><cite>-v</cite></td>
<td><cite>x = element()</cite>;
<cite>lincomb(x, -1, v)</cite></td>
</tr>
<tr class="row-odd"><td colspan="5"><dl class="first last docutils">
<dt><cite>dist(other)</cite>    <a href="#id1"><span class="problematic" id="id2">|</span></a><cite>float</cite>        <a href="#id3"><span class="problematic" id="id4">|</span></a>Distance between this vector and</dt>
<dd><div class="first last line-block">
<div class="line"><a href="#id5"><span class="problematic" id="id6">|</span></a><cite>other</cite></div>
</div>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><cite>norm()</cite></td>
<td colspan="2"><cite>float</cite></td>
<td colspan="2">Length of this vector and</td>
</tr>
<tr class="row-odd"><td><cite>inner(other)</cite></td>
<td colspan="2"><cite>float</cite></td>
<td colspan="2">Inner product of this vector with
<cite>other</cite></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="odl.space.cartesian.Ntuples">
<em class="property">class </em><code class="descclassname">odl.space.cartesian.</code><code class="descname">Ntuples</code><span class="sig-paren">(</span><em>dim</em>, <em>dtype</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cartesian.html#Ntuples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cartesian.Ntuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.set.Set" title="odl.space.set.Set"><code class="xref py py-class docutils literal"><span class="pre">odl.space.set.Set</span></code></a></p>
<p>The set of <cite>n</cite>-tuples of arbitrary type.</p>
<p>See the module documentation for attributes, methods etc.</p>
<dl class="class">
<dt id="odl.space.cartesian.Ntuples.Vector">
<em class="property">class </em><code class="descname">Vector</code><span class="sig-paren">(</span><em>space</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cartesian.html#Ntuples.Vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cartesian.Ntuples.Vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Representation of an <cite>Ntuples</cite> element.</p>
<p>See the module documentation for attributes, methods etc.</p>
<dl class="method">
<dt id="odl.space.cartesian.Ntuples.Vector.assign">
<code class="descname">assign</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cartesian.html#Ntuples.Vector.assign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cartesian.Ntuples.Vector.assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign the values of <cite>other</cite> to this vector.</p>
<dl class="docutils">
<dt>other <span class="classifier-delimiter">:</span> <span class="classifier"><cite>Ntuples.Vector</cite></span></dt>
<dd>The values to be copied to this vector. <cite>other</cite>
must be an element of this vector&#8217;s space.</dd>
</dl>
<p><cite>None</cite></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vec1</span> <span class="o">=</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec2</span> <span class="o">=</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec1</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">vec2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec1</span>
<span class="go">Ntuples(3, int).element([-1, 2, 0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="odl.space.cartesian.Ntuples.Vector.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cartesian.html#Ntuples.Vector.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cartesian.Ntuples.Vector.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an identical (deep) copy of this vector.</p>
<dl class="docutils">
<dt>copy <span class="classifier-delimiter">:</span> <span class="classifier"><cite>Ntuples.Vector</cite></span></dt>
<dd>The deep copy</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vec1</span> <span class="o">=</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec2</span> <span class="o">=</span> <span class="n">vec1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec2</span>
<span class="go">Ntuples(3, int).element([1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec1</span> <span class="o">==</span> <span class="n">vec2</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec1</span> <span class="ow">is</span> <span class="n">vec2</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.cartesian.Ntuples.Vector.data">
<code class="descname">data</code><a class="headerlink" href="#odl.space.cartesian.Ntuples.Vector.data" title="Permalink to this definition">¶</a></dt>
<dd><p>The vector&#8217;s data representation, a <cite>numpy.ndarray</cite>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span> <span class="o">=</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span><span class="o">.</span><span class="n">data</span>
<span class="go">array([1, 2, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.cartesian.Ntuples.Vector.data_ptr">
<code class="descname">data_ptr</code><a class="headerlink" href="#odl.space.cartesian.Ntuples.Vector.data_ptr" title="Permalink to this definition">¶</a></dt>
<dd><p>A raw pointer to the data container.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ctypes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span> <span class="o">=</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&#39;int32&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr_type</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int32</span> <span class="o">*</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">buffer</span> <span class="o">=</span> <span class="n">arr_type</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="n">vec</span><span class="o">.</span><span class="n">data_ptr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="nb">buffer</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span>
<span class="go">array([1, 2, 3])</span>
</pre></div>
</div>
<p>In-place modification via pointer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span>
<span class="go">Ntuples(3, int).element([5, 2, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="odl.space.cartesian.Ntuples.Vector.equals">
<code class="descname">equals</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cartesian.html#Ntuples.Vector.equals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cartesian.Ntuples.Vector.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if <cite>other</cite> is equal to this vector.</p>
<dl class="docutils">
<dt>equals <span class="classifier-delimiter">:</span> <span class="classifier"><cite>bool</cite></span></dt>
<dd><cite>True</cite> if all entries of <cite>other</cite> are equal to this
vector&#8217;s entries, <cite>False</cite> otherwise.</dd>
</dl>
<p>Space membership is not checked, hence vectors from
different spaces can be equal.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vec1</span> <span class="o">=</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec2</span> <span class="o">=</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec1</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">vec2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec2</span> <span class="o">=</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec1</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">vec2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec1</span> <span class="o">==</span> <span class="n">vec2</span>  <span class="c"># equivalent</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Equality can hold across spaces:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vec2</span> <span class="o">=</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec1</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">vec2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">vec2</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">vec1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.cartesian.Ntuples.Vector.space">
<code class="descname">space</code><a class="headerlink" href="#odl.space.cartesian.Ntuples.Vector.space" title="Permalink to this definition">¶</a></dt>
<dd><p>The space this vector belongs to.</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="odl.space.cartesian.Ntuples.contains">
<code class="descclassname">Ntuples.</code><code class="descname">contains</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cartesian.html#Ntuples.contains"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cartesian.Ntuples.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if <cite>other</cite> is contained in this space.</p>
<dl class="docutils">
<dt>contains <span class="classifier-delimiter">:</span> <span class="classifier"><cite>bool</cite></span></dt>
<dd><cite>True</cite> if <cite>other</cite> is an <cite>Ntuples.Vector</cite> instance of and
<cite>other.space</cite> is equal to this space. <cite>False</cite> otherwise.</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">long_3</span> <span class="o">=</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int64&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">long_3</span><span class="o">.</span><span class="n">element</span><span class="p">()</span> <span class="ow">in</span> <span class="n">long_3</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">long_3</span><span class="o">.</span><span class="n">element</span><span class="p">()</span> <span class="ow">in</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int32&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">long_3</span><span class="o">.</span><span class="n">element</span><span class="p">()</span> <span class="ow">in</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.cartesian.Ntuples.dim">
<code class="descclassname">Ntuples.</code><code class="descname">dim</code><a class="headerlink" href="#odl.space.cartesian.Ntuples.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimension of this space.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">int_3</span> <span class="o">=</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int_3</span><span class="o">.</span><span class="n">dim</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.cartesian.Ntuples.dtype">
<code class="descclassname">Ntuples.</code><code class="descname">dtype</code><a class="headerlink" href="#odl.space.cartesian.Ntuples.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The data type of each entry.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">int_3</span> <span class="o">=</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int64&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int_3</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;int64&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="odl.space.cartesian.Ntuples.element">
<code class="descclassname">Ntuples.</code><code class="descname">element</code><span class="sig-paren">(</span><em>inp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cartesian.html#Ntuples.element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cartesian.Ntuples.element" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new element.</p>
<dl class="docutils">
<dt>inp <span class="classifier-delimiter">:</span> <span class="classifier">array-like or scalar, optional</span></dt>
<dd><p class="first">Input to initialize the new element.</p>
<p>If <cite>inp</cite> is <cite>None</cite>, an empty element is created with no
guarantee of its state (memory allocation only).</p>
<p>If <cite>inp</cite> is a <cite>numpy.ndarray</cite> of shape <cite>(dim,)</cite> and the
same data type as this space, the array is wrapped, not
copied.
Other array-like objects are copied (with broadcasting
if necessary).</p>
<p class="last">If a single value is given, it is copied to all entries.</p>
</dd>
</dl>
<dl class="docutils">
<dt>element <span class="classifier-delimiter">:</span> <span class="classifier"><cite>Ntuples.Vector</cite></span></dt>
<dd>The new element created (from <cite>inp</cite>).</dd>
</dl>
<p>This method preserves &#8220;array views&#8221; of correct size and type,
see the examples below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">strings3</span> <span class="o">=</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;S1&#39;</span><span class="p">)</span>  <span class="c"># 1-char strings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">strings3</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="s">&#39;w&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">Ntuples(3, dtype(&#39;S1&#39;)).element([&#39;w&#39;, &#39;b&#39;, &#39;w&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">strings3</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">==</span> <span class="n">x</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">strings3</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">);</span> <span class="k">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">[&#39;b&#39;, &#39;b&#39;, &#39;b&#39;]</span>
</pre></div>
</div>
<p>Array views are preserved:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">strings2</span> <span class="o">=</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;S1&#39;</span><span class="p">)</span>  <span class="c"># 1-char strings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">strings3</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="s">&#39;w&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">strings2</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">x</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>  <span class="c"># view into x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="s">&#39;x&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[&#39;x&#39;, &#39;b&#39;, &#39;x&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="odl.space.cartesian.Ntuples.equals">
<code class="descclassname">Ntuples.</code><code class="descname">equals</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cartesian.html#Ntuples.equals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cartesian.Ntuples.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if <cite>other</cite> is equal to this space.</p>
<dl class="docutils">
<dt>equals <span class="classifier-delimiter">:</span> <span class="classifier"><cite>bool</cite></span></dt>
<dd><cite>True</cite> if <cite>other</cite> is an instance of this space&#8217;s type
with the same <cite>dim</cite> and <cite>dtype</cite>, otherwise <cite>False</cite>.</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">int_3</span> <span class="o">=</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int_3</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">int_3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Equality is not identity:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">int_3a</span><span class="p">,</span> <span class="n">int_3b</span> <span class="o">=</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int_3a</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">int_3b</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int_3a</span> <span class="ow">is</span> <span class="n">int_3b</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">int_3</span><span class="p">,</span> <span class="n">int_4</span> <span class="o">=</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int_3</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">int_4</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int_3</span><span class="p">,</span> <span class="n">str_3</span> <span class="o">=</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&#39;int&#39;</span><span class="p">),</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&#39;string&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int_3</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">str_3</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Equality can also be checked with &#8220;==&#8221;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">int_3</span><span class="p">,</span> <span class="n">int_4</span> <span class="o">=</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="n">Ntuples</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int_3</span> <span class="o">==</span> <span class="n">int_3</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int_3</span> <span class="o">==</span> <span class="n">int_4</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int_3</span> <span class="o">!=</span> <span class="n">int_4</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odl.space.cartesian.Fn">
<em class="property">class </em><code class="descclassname">odl.space.cartesian.</code><code class="descname">Fn</code><span class="sig-paren">(</span><em>dim</em>, <em>dtype</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cartesian.html#Fn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cartesian.Fn" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.cartesian.Ntuples" title="odl.space.cartesian.Ntuples"><code class="xref py py-class docutils literal"><span class="pre">odl.space.cartesian.Ntuples</span></code></a>, <a class="reference internal" href="#odl.space.space.LinearSpace" title="odl.space.space.LinearSpace"><code class="xref py py-class docutils literal"><span class="pre">odl.space.space.LinearSpace</span></code></a></p>
<p>The complex vector space <img class="math" src="_images/math/ec87ef588913f233c39ea2c4a771f03ffc478e72.png" alt="E^n"/> with vector multiplication.</p>
<p>Its elements are represented as instances of the inner <cite>Cn.Vector</cite>
class.</p>
<p>See the module documentation for attributes, methods etc.</p>
<dl class="class">
<dt id="odl.space.cartesian.Fn.Vector">
<em class="property">class </em><code class="descname">Vector</code><span class="sig-paren">(</span><em>space</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cartesian.html#Fn.Vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cartesian.Fn.Vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">odl.space.cartesian.Vector</span></code>, <code class="xref py py-class docutils literal"><span class="pre">odl.space.space.Vector</span></code></p>
<p>Representation of a <cite>Fn</cite> element.</p>
<p>See the module documentation for attributes, methods etc.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.cartesian.Fn.equals">
<code class="descclassname">Fn.</code><code class="descname">equals</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cartesian.html#Fn.equals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cartesian.Fn.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if <cite>other</cite> is equal to this space.</p>
<dl class="docutils">
<dt>equals <span class="classifier-delimiter">:</span> <span class="classifier"><cite>bool</cite></span></dt>
<dd><cite>True</cite> if <cite>other</cite> is an instance of this space&#8217;s type
with the same <cite>dim</cite> and <cite>dtype</cite>, and <strong>identical</strong>
distance function, otherwise <cite>False</cite>.</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nb">ord</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">norm</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span> <span class="nb">ord</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist2</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c3</span> <span class="o">=</span> <span class="n">Cn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="n">dist2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c3_same</span> <span class="o">=</span> <span class="n">Cn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="n">dist2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c3</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">c3_same</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c3</span> <span class="o">==</span> <span class="n">c3_same</span>  <span class="c"># equivalent</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Different <cite>dist</cite> functions result in different spaces:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dist1</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c3_1</span> <span class="o">=</span> <span class="n">Cn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="n">dist1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c3_2</span> <span class="o">=</span> <span class="n">Cn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="n">dist2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c3_1</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">c3_2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Be careful with Lambdas - they result in non-identical function
objects:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c3_lambda1</span> <span class="o">=</span> <span class="n">Cn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c3_lambda2</span> <span class="o">=</span> <span class="n">Cn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c3_lambda1</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">c3_lambda2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.cartesian.Fn.field">
<code class="descclassname">Fn.</code><code class="descname">field</code><a class="headerlink" href="#odl.space.cartesian.Fn.field" title="Permalink to this definition">¶</a></dt>
<dd><p>The field of <img class="math" src="_images/math/2383a69a5b4b04f7d62a0b0cf16d18f5ea55bb0e.png" alt="C^n"/>, i.e. the complex numbers.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c3</span> <span class="o">=</span> <span class="n">Cn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c3</span><span class="o">.</span><span class="n">field</span>
<span class="go">ComplexNumbers()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="odl.space.cartesian.Fn.zero">
<code class="descclassname">Fn.</code><code class="descname">zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cartesian.html#Fn.zero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cartesian.Fn.zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a vector of zeros.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c3</span> <span class="o">=</span> <span class="n">Cn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">c3</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">Cn(3).element([0j, 0j, 0j])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odl.space.cartesian.Cn">
<em class="property">class </em><code class="descclassname">odl.space.cartesian.</code><code class="descname">Cn</code><span class="sig-paren">(</span><em>dim</em>, <em>dtype=&lt;type 'numpy.complex128'&gt;</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cartesian.html#Cn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cartesian.Cn" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.cartesian.Fn" title="odl.space.cartesian.Fn"><code class="xref py py-class docutils literal"><span class="pre">odl.space.cartesian.Fn</span></code></a></p>
<p>The real vector space <img class="math" src="_images/math/4b2f86413eb03ebbcc1b0ffd8f4669fa28e3575b.png" alt="R^n"/> with vector multiplication.</p>
<p>Its elements are represented as instances of the inner <cite>Rn.Vector</cite>
class.</p>
<p>See the module documentation for attributes, methods etc.</p>
<dl class="class">
<dt id="odl.space.cartesian.Cn.Vector">
<em class="property">class </em><code class="descname">Vector</code><span class="sig-paren">(</span><em>space</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cartesian.html#Cn.Vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cartesian.Cn.Vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">odl.space.cartesian.Vector</span></code></p>
<p>Representation of a <cite>Cn</cite> element.</p>
<p>See the module documentation for attributes, methods etc.</p>
<dl class="attribute">
<dt id="odl.space.cartesian.Cn.Vector.imag">
<code class="descname">imag</code><a class="headerlink" href="#odl.space.cartesian.Cn.Vector.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>The imaginary part of this vector.</p>
<dl class="docutils">
<dt>imag <span class="classifier-delimiter">:</span> <span class="classifier"><cite>Rn.Vector</cite></span></dt>
<dd>The imaginary part this vector as a vector in <cite>Rn</cite></dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c3</span> <span class="o">=</span> <span class="n">Cn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">c3</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="mi">5</span><span class="o">+</span><span class="mi">1j</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">-</span><span class="mi">2j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">imag</span>
<span class="go">Rn(3).element([1.0, 0.0, -2.0])</span>
</pre></div>
</div>
<p>The <cite>Rn</cite> vector is really a view, so changes affect
the original array:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">imag</span> <span class="o">*=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">Cn(3).element([(5+2j), (3+0j), (2-4j)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.cartesian.Cn.Vector.real">
<code class="descname">real</code><a class="headerlink" href="#odl.space.cartesian.Cn.Vector.real" title="Permalink to this definition">¶</a></dt>
<dd><p>The real part of this vector.</p>
<dl class="docutils">
<dt>real <span class="classifier-delimiter">:</span> <span class="classifier"><cite>Rn.Vector</cite> view</span></dt>
<dd>The real part this vector as a vector in <cite>Rn</cite></dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c3</span> <span class="o">=</span> <span class="n">Cn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">c3</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="mi">5</span><span class="o">+</span><span class="mi">1j</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">-</span><span class="mi">2j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">real</span>
<span class="go">Rn(3).element([5.0, 3.0, 2.0])</span>
</pre></div>
</div>
<p>The <cite>Rn</cite> vector is really a view, so changes affect
the original array:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">real</span> <span class="o">*=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">Cn(3).element([(10+1j), (6+0j), (4-2j)])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odl.space.cartesian.Rn">
<em class="property">class </em><code class="descclassname">odl.space.cartesian.</code><code class="descname">Rn</code><span class="sig-paren">(</span><em>dim</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cartesian.html#Rn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cartesian.Rn" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.cartesian.Fn" title="odl.space.cartesian.Fn"><code class="xref py py-class docutils literal"><span class="pre">odl.space.cartesian.Fn</span></code></a></p>
<p>The real vector space <img class="math" src="_images/math/4b2f86413eb03ebbcc1b0ffd8f4669fa28e3575b.png" alt="R^n"/> with vector multiplication.</p>
<p>Its elements are represented as instances of the inner <cite>Rn.Vector</cite>
class.</p>
<p>See the module documentation for attributes, methods etc.</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-odl.space.cuda">
<span id="odl-space-cuda-module"></span><h2>odl.space.cuda module<a class="headerlink" href="#module-odl.space.cuda" title="Permalink to this headline">¶</a></h2>
<p>CUDA implementation of n-dimensional Cartesian spaces.</p>
<p># TODO: document public interface</p>
<dl class="class">
<dt id="odl.space.cuda.CudaFn">
<em class="property">class </em><code class="descclassname">odl.space.cuda.</code><code class="descname">CudaFn</code><span class="sig-paren">(</span><em>dim</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cuda.html#CudaFn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cuda.CudaFn" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.space.LinearSpace" title="odl.space.space.LinearSpace"><code class="xref py py-class docutils literal"><span class="pre">odl.space.space.LinearSpace</span></code></a></p>
<p>The real space E^n, implemented in CUDA.</p>
<p>Requires the compiled ODL extension odlpp.</p>
<p># TODO: document public interface</p>
<dl class="class">
<dt id="odl.space.cuda.CudaFn.Vector">
<em class="property">class </em><code class="descname">Vector</code><span class="sig-paren">(</span><em>space</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cuda.html#CudaFn.Vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cuda.CudaFn.Vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">odl.space.space.Vector</span></code></p>
<p>An E^n vector represented in CUDA.</p>
<p># TODO: document public interface</p>
<dl class="attribute">
<dt id="odl.space.cuda.CudaFn.Vector.data">
<code class="descname">data</code><a class="headerlink" href="#odl.space.cuda.CudaFn.Vector.data" title="Permalink to this definition">¶</a></dt>
<dd><p>The data of this vector.</p>
<p>None</p>
<dl class="docutils">
<dt>ptr <span class="classifier-delimiter">:</span> <span class="classifier">CudaFnVectorImpl</span></dt>
<dd>Underlying cuda data representation</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.cuda.CudaFn.Vector.data_ptr">
<code class="descname">data_ptr</code><a class="headerlink" href="#odl.space.cuda.CudaFn.Vector.data_ptr" title="Permalink to this definition">¶</a></dt>
<dd><p>A raw pointer to the data of this vector.</p>
<p>None</p>
<dl class="docutils">
<dt>ptr <span class="classifier-delimiter">:</span> <span class="classifier">Int</span></dt>
<dd>Pointer to the CUDA data of this vector</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Zn</span> <span class="o">=</span> <span class="n">CudaFn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Zn</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">CudaFn(3, int).element([1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">Zn</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">data_ptr</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">data_ptr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">CudaFn(3, int).element([1, 2, 3])</span>
</pre></div>
</div>
<p>In-place modification via pointer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">CudaFn(3, int).element([5, 2, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.cuda.CudaFn.Vector.itemsize">
<code class="descname">itemsize</code><a class="headerlink" href="#odl.space.cuda.CudaFn.Vector.itemsize" title="Permalink to this definition">¶</a></dt>
<dd><p>The size in bytes of the underlying element type.</p>
<p>None</p>
<dl class="docutils">
<dt>itemsize <span class="classifier-delimiter">:</span> <span class="classifier">Int</span></dt>
<dd>Size in bytes of type</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="odl.space.cuda.CudaFn.dim">
<code class="descclassname">CudaFn.</code><code class="descname">dim</code><a class="headerlink" href="#odl.space.cuda.CudaFn.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimension of this space.</p>
<p>None</p>
<p>Integer</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rn</span> <span class="o">=</span> <span class="n">CudaFn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rn</span><span class="o">.</span><span class="n">dim</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.cuda.CudaFn.dtypes">
<code class="descclassname">CudaFn.</code><code class="descname">dtypes</code><em class="property"> = {dtype('uint64'): &lt;class 'odlpp.odlpp_cuda.CudaVectorUInt64'&gt;, dtype('int8'): &lt;class 'odlpp.odlpp_cuda.CudaVectorInt8'&gt;, dtype('uint8'): &lt;class 'odlpp.odlpp_cuda.CudaVectorUInt8'&gt;, dtype('int16'): &lt;class 'odlpp.odlpp_cuda.CudaVectorInt16'&gt;, dtype('float64'): &lt;class 'odlpp.odlpp_cuda.CudaVectorFloat64'&gt;, dtype('uint16'): &lt;class 'odlpp.odlpp_cuda.CudaVectorUInt16'&gt;, dtype('uint32'): &lt;class 'odlpp.odlpp_cuda.CudaVectorUInt32'&gt;, dtype('int32'): &lt;class 'odlpp.odlpp_cuda.CudaVectorInt32'&gt;, dtype('float32'): &lt;class 'odlpp.odlpp_cuda.CudaVectorFloat32'&gt;, dtype('int64'): &lt;class 'odlpp.odlpp_cuda.CudaVectorInt64'&gt;}</em><a class="headerlink" href="#odl.space.cuda.CudaFn.dtypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odl.space.cuda.CudaFn.element">
<code class="descclassname">CudaFn.</code><code class="descname">element</code><span class="sig-paren">(</span><em>inp=None</em>, <em>data_ptr=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cuda.html#CudaFn.element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cuda.CudaFn.element" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an element from given data or from scratch.</p>
<p>TODO: write up properly</p>
<p>inp : array-like, optional</p>
<p>The method has two call patterns, the first is:</p>
<dl class="docutils">
<dt><a href="#id7"><span class="problematic" id="id8">*</span></a>args <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>Array that will be copied to the GPU.
Data is not modified or bound.
The shape of the array must be (n,)</dd>
</dl>
<p><a href="#id9"><span class="problematic" id="id10">**</span></a>kwargs : None</p>
<p>The second pattern is to create a new numpy array which will then
be copied to the GPU. In this case</p>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>args : Options for numpy.array constructor
<a href="#id13"><span class="problematic" id="id14">**</span></a>kwargs : Options for numpy.array constructor</p>
<p>CudaFn.Vector instance</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rn</span> <span class="o">=</span> <span class="n">CudaFn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">rn</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">CudaFn(3).element([1.0, 2.0, 3.0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">rn</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">CudaFn(3).element([1.0, 2.0, 3.0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="odl.space.cuda.CudaFn.equals">
<code class="descclassname">CudaFn.</code><code class="descname">equals</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cuda.html#CudaFn.equals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cuda.CudaFn.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if <cite>other</cite> is a CudaFn instance of the same dimension.</p>
<dl class="docutils">
<dt>other <span class="classifier-delimiter">:</span> <span class="classifier">any object</span></dt>
<dd>The object to check for equality</dd>
</dl>
<dl class="docutils">
<dt>eq <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>True if equal, else false</dd>
</dl>
<p>Comparing with self:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r3</span> <span class="o">=</span> <span class="n">CudaFn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r3</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">r3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r3a</span><span class="p">,</span> <span class="n">r3b</span> <span class="o">=</span> <span class="n">CudaFn</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">CudaFn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r3a</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">r3b</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>False when comparing to other dimension Rn:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r3</span><span class="p">,</span> <span class="n">r4</span> <span class="o">=</span> <span class="n">CudaFn</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">CudaFn</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r3</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">r4</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We also support operators &#8216;==&#8217; and &#8216;!=&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">r3</span><span class="p">,</span> <span class="n">r4</span> <span class="o">=</span> <span class="n">CudaFn</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">CudaFn</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r3</span> <span class="o">==</span> <span class="n">r3</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r3</span> <span class="o">==</span> <span class="n">r4</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r3</span> <span class="o">!=</span> <span class="n">r4</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.cuda.CudaFn.field">
<code class="descclassname">CudaFn.</code><code class="descname">field</code><a class="headerlink" href="#odl.space.cuda.CudaFn.field" title="Permalink to this definition">¶</a></dt>
<dd><p>The underlying field of R^n is the set of real numbers.</p>
<p>None</p>
<p>RealNumbers instance</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rn</span> <span class="o">=</span> <span class="n">CudaFn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rn</span><span class="o">.</span><span class="n">field</span>
<span class="go">RealNumbers()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="odl.space.cuda.CudaFn.zero">
<code class="descclassname">CudaFn.</code><code class="descname">zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cuda.html#CudaFn.zero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cuda.CudaFn.zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a vector of zeros.</p>
<p>None</p>
<p>CudaFn.Vector instance with all elements set to zero (0.0)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rn</span> <span class="o">=</span> <span class="n">CudaFn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">rn</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">CudaFn(3).element([0.0, 0.0, 0.0])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odl.space.cuda.CudaRn">
<em class="property">class </em><code class="descclassname">odl.space.cuda.</code><code class="descname">CudaRn</code><span class="sig-paren">(</span><em>dim</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cuda.html#CudaRn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cuda.CudaRn" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.cuda.CudaFn" title="odl.space.cuda.CudaFn"><code class="xref py py-class docutils literal"><span class="pre">odl.space.cuda.CudaFn</span></code></a></p>
<p>The real space <img class="math" src="_images/math/4b2f86413eb03ebbcc1b0ffd8f4669fa28e3575b.png" alt="R^n"/>, implemented in CUDA.</p>
<p>Requires the compiled ODL extension odlpp.</p>
<p># TODO: document public interface</p>
<dl class="class">
<dt id="odl.space.cuda.CudaRn.Vector">
<em class="property">class </em><code class="descname">Vector</code><span class="sig-paren">(</span><em>space</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cuda.html#CudaRn.Vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cuda.CudaRn.Vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">odl.space.cuda.Vector</span></code></p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="odl.space.cuda.abs">
<code class="descclassname">odl.space.cuda.</code><code class="descname">abs</code><span class="sig-paren">(</span><em>inp</em>, <em>outp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cuda.html#abs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cuda.abs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="odl.space.cuda.add_scalar">
<code class="descclassname">odl.space.cuda.</code><code class="descname">add_scalar</code><span class="sig-paren">(</span><em>inp</em>, <em>scal</em>, <em>outp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cuda.html#add_scalar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cuda.add_scalar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="odl.space.cuda.max_vector_scalar">
<code class="descclassname">odl.space.cuda.</code><code class="descname">max_vector_scalar</code><span class="sig-paren">(</span><em>inp</em>, <em>scal</em>, <em>outp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cuda.html#max_vector_scalar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cuda.max_vector_scalar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="odl.space.cuda.max_vector_vector">
<code class="descclassname">odl.space.cuda.</code><code class="descname">max_vector_vector</code><span class="sig-paren">(</span><em>inp1</em>, <em>inp2</em>, <em>outp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cuda.html#max_vector_vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cuda.max_vector_vector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="odl.space.cuda.sign">
<code class="descclassname">odl.space.cuda.</code><code class="descname">sign</code><span class="sig-paren">(</span><em>inp</em>, <em>outp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cuda.html#sign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cuda.sign" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="odl.space.cuda.sum">
<code class="descclassname">odl.space.cuda.</code><code class="descname">sum</code><span class="sig-paren">(</span><em>inp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/cuda.html#sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.cuda.sum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-odl.space.function">
<span id="odl-space-function-module"></span><h2>odl.space.function module<a class="headerlink" href="#module-odl.space.function" title="Permalink to this headline">¶</a></h2>
<p>Support for functionspaces, such as L2.</p>
<dl class="class">
<dt id="odl.space.function.FunctionSpace">
<em class="property">class </em><code class="descclassname">odl.space.function.</code><code class="descname">FunctionSpace</code><span class="sig-paren">(</span><em>domain</em>, <em>field=RealNumbers()</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/function.html#FunctionSpace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.function.FunctionSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.space.LinearSpace" title="odl.space.space.LinearSpace"><code class="xref py py-class docutils literal"><span class="pre">odl.space.space.LinearSpace</span></code></a></p>
<p>The space of scalar valued functions on some domain</p>
<dl class="docutils">
<dt>domain <span class="classifier-delimiter">:</span> <span class="classifier">Set</span></dt>
<dd>The set the functions take values from</dd>
<dt>field <span class="classifier-delimiter">:</span> <span class="classifier">{RealNumbers, ComplexNumbers}, optional</span></dt>
<dd>The field that the functions map values into.
Since FunctionSpace is a LinearSpace, this is also
the set of scalars for this space.</dd>
</dl>
<dl class="class">
<dt id="odl.space.function.FunctionSpace.Vector">
<em class="property">class </em><code class="descname">Vector</code><span class="sig-paren">(</span><em>space</em>, <em>function</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/function.html#FunctionSpace.Vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.function.FunctionSpace.Vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">odl.operator.operator._DefaultApplyOperator</span></code>, <code class="xref py py-class docutils literal"><span class="pre">odl.space.space.Vector</span></code>, <a class="reference internal" href="odl.operator.html#odl.operator.operator.Operator" title="odl.operator.operator.Operator"><code class="xref py py-class docutils literal"><span class="pre">odl.operator.operator.Operator</span></code></a></p>
<p>A Vector in a FunctionSpace</p>
<p>FunctionSpace-Vectors are themselves also Functionals, and inherit
a large set of features from them.</p>
<dl class="docutils">
<dt>space <span class="classifier-delimiter">:</span> <span class="classifier">FunctionSpace</span></dt>
<dd>Instance of FunctionSpace this vector lives in</dd>
<dt>function <span class="classifier-delimiter">:</span> <span class="classifier">Function from space.domain to space.field</span></dt>
<dd>The function that should be converted/reinterpreted as a vector.</dd>
</dl>
<dl class="attribute">
<dt id="odl.space.function.FunctionSpace.Vector.domain">
<code class="descname">domain</code><a class="headerlink" href="#odl.space.function.FunctionSpace.Vector.domain" title="Permalink to this definition">¶</a></dt>
<dd><p>The range of this Vector (when viewed as a functional)</p>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.function.FunctionSpace.Vector.range">
<code class="descname">range</code><a class="headerlink" href="#odl.space.function.FunctionSpace.Vector.range" title="Permalink to this definition">¶</a></dt>
<dd><p>The range of this Vector (when viewed as a functional)</p>
<p>The range is the same as the field of the vectors space</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="odl.space.function.FunctionSpace.element">
<code class="descclassname">FunctionSpace.</code><code class="descname">element</code><span class="sig-paren">(</span><em>funct=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/function.html#FunctionSpace.element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.function.FunctionSpace.element" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an element in FunctionSpace</p>
<dl class="docutils">
<dt>funct <span class="classifier-delimiter">:</span> <span class="classifier">Function from self.domain to self.field</span></dt>
<dd>The function that should be converted/reinterpreted
as a vector.</dd>
</dl>
<p>FunctionSpace.Vector instance</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">RealNumbers</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">space</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">9.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="odl.space.function.FunctionSpace.equals">
<code class="descclassname">FunctionSpace.</code><code class="descname">equals</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/function.html#FunctionSpace.equals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.function.FunctionSpace.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify that other is a FunctionSpace with the same domain and field</p>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.function.FunctionSpace.field">
<code class="descclassname">FunctionSpace.</code><code class="descname">field</code><a class="headerlink" href="#odl.space.function.FunctionSpace.field" title="Permalink to this definition">¶</a></dt>
<dd><p>The field that the functions map values into.</p>
<p>Since FunctionSpace is a LinearSpace, this is also
the set of scalars for this space.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.function.FunctionSpace.zero">
<code class="descclassname">FunctionSpace.</code><code class="descname">zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/function.html#FunctionSpace.zero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.function.FunctionSpace.zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the zero function
The function which maps any value to zero</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odl.space.function.L2">
<em class="property">class </em><code class="descclassname">odl.space.function.</code><code class="descname">L2</code><span class="sig-paren">(</span><em>domain</em>, <em>field=RealNumbers()</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/function.html#L2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.function.L2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.function.FunctionSpace" title="odl.space.function.FunctionSpace"><code class="xref py py-class docutils literal"><span class="pre">odl.space.function.FunctionSpace</span></code></a></p>
<p>The space of square integrable functions on some domain</p>
<dl class="class">
<dt id="odl.space.function.L2.Vector">
<em class="property">class </em><code class="descname">Vector</code><span class="sig-paren">(</span><em>space</em>, <em>function</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/function.html#L2.Vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.function.L2.Vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">odl.space.function.Vector</span></code></p>
<p>A Vector in a L2-space</p>
<p>FunctionSpace-Vectors are themselves also Functionals, and inherit
a large set of features from them.</p>
<dl class="docutils">
<dt>space <span class="classifier-delimiter">:</span> <span class="classifier">FunctionSpace</span></dt>
<dd>Instance of FunctionSpace this vector lives in</dd>
<dt>function <span class="classifier-delimiter">:</span> <span class="classifier">Function from space.domain to space.field</span></dt>
<dd>The function that should be converted/reinterpreted as a vector.</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-odl.space.product">
<span id="odl-space-product-module"></span><h2>odl.space.product module<a class="headerlink" href="#module-odl.space.product" title="Permalink to this headline">¶</a></h2>
<p>Cartesian products of <a href="#id15"><span class="problematic" id="id16">`</span></a>LinearSpace`s.</p>
<p>TODO: document public interface</p>
<dl class="class">
<dt id="odl.space.product.ProductSpace">
<em class="property">class </em><code class="descclassname">odl.space.product.</code><code class="descname">ProductSpace</code><span class="sig-paren">(</span><em>*spaces</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/product.html#ProductSpace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.product.ProductSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.space.LinearSpace" title="odl.space.space.LinearSpace"><code class="xref py py-class docutils literal"><span class="pre">odl.space.space.LinearSpace</span></code></a></p>
<p>The Cartesian product of N linear spaces.</p>
<p>The product X1 x ... x XN is itself a linear space, where the
linear combination is defined component-wise.</p>
<p>TODO: document public interface</p>
<dl class="class">
<dt id="odl.space.product.ProductSpace.Vector">
<em class="property">class </em><code class="descname">Vector</code><span class="sig-paren">(</span><em>space</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/product.html#ProductSpace.Vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.product.ProductSpace.Vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">odl.space.space.Vector</span></code></p>
</dd></dl>

<dl class="method">
<dt id="odl.space.product.ProductSpace.element">
<code class="descclassname">ProductSpace.</code><code class="descname">element</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/product.html#ProductSpace.element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.product.ProductSpace.element" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an element in the product space.</p>
<p>The method has three call patterns, the first is:</p>
<dl class="docutils">
<dt>args <span class="classifier-delimiter">:</span> <span class="classifier">None</span></dt>
<dd>Create a new vector from scratch.</dd>
</dl>
<p>The second is to wrap existing vectors:</p>
<dl class="docutils">
<dt>args <span class="classifier-delimiter">:</span> <span class="classifier">tuple of <a href="#id17"><span class="problematic" id="id18">`</span></a>LinearSpace.Vector`s</span></dt>
<dd>A tuple of vectors in the underlying spaces.
This will simply wrap the Vectors (not copy).</dd>
</dl>
<p>The third pattern is to create a new Vector from scratch, in
this case</p>
<p>args : tuple of array-like objects</p>
<p>ProductSpace.Vector instance</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">odl.space.cartesian</span> <span class="kn">import</span> <span class="n">Rn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span><span class="p">,</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">Rn</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">Rn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec_2</span><span class="p">,</span> <span class="n">vec_3</span> <span class="o">=</span> <span class="n">r2</span><span class="o">.</span><span class="n">element</span><span class="p">(),</span> <span class="n">r3</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2x3</span> <span class="o">=</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="n">r3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec_2x3</span> <span class="o">=</span> <span class="n">r2x3</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec_2</span><span class="o">.</span><span class="n">space</span> <span class="o">==</span> <span class="n">vec_2x3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">space</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec_3</span><span class="o">.</span><span class="n">space</span> <span class="o">==</span> <span class="n">vec_2x3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">space</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Creates an element in the product space
&gt;&gt;&gt; from odl.space.cartesian import Rn
&gt;&gt;&gt; r2, r3 = Rn(2), Rn(3)
&gt;&gt;&gt; prod = ProductSpace(r2, r3)
&gt;&gt;&gt; x2 = r2.element([1, 2])
&gt;&gt;&gt; x3 = r3.element([1, 2, 3])
&gt;&gt;&gt; x = prod.element(x2, x3)
&gt;&gt;&gt; print(x)
{[1.0, 2.0], [1.0, 2.0, 3.0]}</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.product.ProductSpace.equals">
<code class="descclassname">ProductSpace.</code><code class="descname">equals</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/product.html#ProductSpace.equals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.product.ProductSpace.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the <cite>other</cite> is the same product space.</p>
<dl class="docutils">
<dt>other <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd>The object to be compared</dd>
</dl>
<dl class="docutils">
<dt>equal <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><cite>True</cite> if <cite>other</cite> is a ProductSpace instance, has
the same length and the same factors. <cite>False</cite> otherwise.</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">odl.space.cartesian</span> <span class="kn">import</span> <span class="n">Rn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span><span class="p">,</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">Rn</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">Rn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rn</span><span class="p">,</span> <span class="n">rm</span> <span class="o">=</span> <span class="n">Rn</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">Rn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2x3</span><span class="p">,</span> <span class="n">rnxm</span> <span class="o">=</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="n">r3</span><span class="p">),</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="n">rn</span><span class="p">,</span> <span class="n">rm</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2x3</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">rnxm</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r3x2</span> <span class="o">=</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="n">r3</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2x3</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">r3x2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r5</span> <span class="o">=</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">Rn</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2x3</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">r5</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r5</span> <span class="o">=</span> <span class="n">Rn</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2x3</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">r5</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.product.ProductSpace.field">
<code class="descclassname">ProductSpace.</code><code class="descname">field</code><a class="headerlink" href="#odl.space.product.ProductSpace.field" title="Permalink to this definition">¶</a></dt>
<dd><p>The common underlying field of all factors.</p>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.product.ProductSpace.spaces">
<code class="descclassname">ProductSpace.</code><code class="descname">spaces</code><a class="headerlink" href="#odl.space.product.ProductSpace.spaces" title="Permalink to this definition">¶</a></dt>
<dd><p>A tuple containing all spaces.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.product.ProductSpace.zero">
<code class="descclassname">ProductSpace.</code><code class="descname">zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/product.html#ProductSpace.zero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.product.ProductSpace.zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the zero vector of the product space.</p>
<p>The i:th component of the product space zero vector is the
zero vector of the i:th space in the product.</p>
<p>None</p>
<dl class="docutils">
<dt>zero <span class="classifier-delimiter">:</span> <span class="classifier">ProducSpace.Vector</span></dt>
<dd>The zero vector in the product space</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">odl.space.cartesian</span> <span class="kn">import</span> <span class="n">Rn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2</span><span class="p">,</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">Rn</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">Rn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zero_2</span><span class="p">,</span> <span class="n">zero_3</span> <span class="o">=</span> <span class="n">r2</span><span class="o">.</span><span class="n">zero</span><span class="p">(),</span> <span class="n">r3</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r2x3</span> <span class="o">=</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="n">r3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zero_2x3</span> <span class="o">=</span> <span class="n">r2x3</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zero_2</span> <span class="o">==</span> <span class="n">zero_2x3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zero_3</span> <span class="o">==</span> <span class="n">zero_2x3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="odl.space.product.powerspace">
<code class="descclassname">odl.space.product.</code><code class="descname">powerspace</code><span class="sig-paren">(</span><em>base</em>, <em>power</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/product.html#powerspace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.product.powerspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a power space X^N = X x ... x X</p>
<p>Selects the &#8216;most powerful&#8217; space possible, i.e. if all spaces
are HilbertSpace instances, a HilbertProductSpace instance is
returned.</p>
<dl class="docutils">
<dt>base <span class="classifier-delimiter">:</span> <span class="classifier">&lt;Which&gt;Space instance</span></dt>
<dd>&lt;Which&gt; is either Hilbert, Normed, Metric or Linear</dd>
<dt>power <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The number of factors in the product</dd>
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">{&#8216;ord&#8217;, &#8216;weights&#8217;, &#8216;prod_norm&#8217;}</span></dt>
<dd><dl class="first last docutils">
<dt>&#8216;ord&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd>Order of the product distance/norm, i.e.
dist(x, y) = np.linalg.norm(x-y, ord=ord)
norm(x) = np.linalg.norm(x, ord=ord)
If used, forces the space to not be a hilbert space.
Default: 2.0</dd>
<dt>&#8216;weights&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">array-like, optional, only usable with &#8216;ord&#8217; option.</span></dt>
<dd>Array of weights, same size as number of space
components. All weights must be positive. It is
multiplied with the tuple of distances before
applying the Rn norm or &#8216;prod_norm&#8217;.
Default: (1.0,...,1.0)</dd>
<dt>&#8216;prod_norm&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">callable, optional</span></dt>
<dd><p class="first">Function that should be applied to the array of
distances/norms
If used, forces the space to not be a hilbert space.
Defaults if applicable:</p>
<blockquote class="last">
<div>dist = np.linalg.norm(x-y, ord=ord)
norm = np.linalg.norm(x, ord=ord)</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<dl class="docutils">
<dt>prodspace <span class="classifier-delimiter">:</span> <span class="classifier">&lt;Which&gt;ProductSpace instance</span></dt>
<dd>&lt;Which&gt; is either Hilbert, Normed, Metric or Linear</dd>
</dl>
<p>powerspace(Rn(1), 2) is mathematically equivalent to Rn(2),
however the latter is usually more efficient numerically.</p>
<p>ProductSpace</p>
</dd></dl>

<dl class="function">
<dt id="odl.space.product.productspace">
<code class="descclassname">odl.space.product.</code><code class="descname">productspace</code><span class="sig-paren">(</span><em>*spaces</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/product.html#productspace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.product.productspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a product space X1 x ... x XN</p>
<p>Selects the &#8216;most powerful&#8217; space possible, i.e. if all spaces
are HilbertSpace instances, a HilbertProductSpace instance is
returned.</p>
<dl class="docutils">
<dt>spaces <span class="classifier-delimiter">:</span> <span class="classifier">&lt;Which&gt;Space instances</span></dt>
<dd>&lt;Which&gt; is either Hilbert, Normed, Metric or Linear</dd>
<dt>kwargs <span class="classifier-delimiter">:</span> <span class="classifier">{&#8216;ord&#8217;, &#8216;weights&#8217;, &#8216;prod_norm&#8217;}</span></dt>
<dd><dl class="first last docutils">
<dt>&#8216;ord&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd>Order of the product distance/norm, i.e.
dist(x, y) = np.linalg.norm(x-y, ord=ord)
norm(x) = np.linalg.norm(x, ord=ord)
If used, forces the space to not be a Hilbert space.
Default: 2.0</dd>
<dt>&#8216;weights&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">array-like, optional, only usable with the</span></dt>
<dd><blockquote class="first">
<div>&#8216;ord&#8217; option.</div></blockquote>
<p class="last">Array of weights, same size as number of space
components. All weights must be positive. It is
multiplied with the tuple of distances before
applying the Rn norm or &#8216;prod_norm&#8217;.
Default: (1.0,...,1.0)</p>
</dd>
<dt>&#8216;prod_norm&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">callable, optional</span></dt>
<dd><p class="first">Function that should be applied to the array of
distances/norms.
If used, forces the space to not be a Hilbert space.
Defaults if applicable:</p>
<blockquote class="last">
<div>dist = np.linalg.norm(x-y, ord=ord)
norm = np.linalg.norm(x, ord=ord)
inner = np.vdot(x,y)</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<dl class="docutils">
<dt>prodspace <span class="classifier-delimiter">:</span> <span class="classifier">&lt;Which&gt;ProductSpace instance</span></dt>
<dd>&lt;Which&gt; is either Hilbert, Normed, Metric or Linear</dd>
</dl>
<p>productspace(Rn(1), Rn(1)) is mathematically equivalent to Rn(2),
however the latter is usually more efficient numerically.</p>
<p>ProductSpace, MetricProductSpace, NormedProductSpace,
HilbertProductSpace</p>
</dd></dl>

</div>
<div class="section" id="module-odl.space.sequence">
<span id="odl-space-sequence-module"></span><h2>odl.space.sequence module<a class="headerlink" href="#module-odl.space.sequence" title="Permalink to this headline">¶</a></h2>
<p>Examples of sequence spaces, function spaces defined on the integers.</p>
<dl class="class">
<dt id="odl.space.sequence.SequenceSpace">
<em class="property">class </em><code class="descclassname">odl.space.sequence.</code><code class="descname">SequenceSpace</code><a class="reference internal" href="_modules/odl/space/sequence.html#SequenceSpace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.sequence.SequenceSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.function.FunctionSpace" title="odl.space.function.FunctionSpace"><code class="xref py py-class docutils literal"><span class="pre">odl.space.function.FunctionSpace</span></code></a></p>
<p>The space of sequences</p>
</dd></dl>

<dl class="class">
<dt id="odl.space.sequence.TruncationDiscretization">
<em class="property">class </em><code class="descclassname">odl.space.sequence.</code><code class="descname">TruncationDiscretization</code><span class="sig-paren">(</span><em>parent</em>, <em>n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/sequence.html#TruncationDiscretization"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.sequence.TruncationDiscretization" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.cartesian.Rn" title="odl.space.cartesian.Rn"><code class="xref py py-class docutils literal"><span class="pre">odl.space.cartesian.Rn</span></code></a></p>
<p>Truncation discretization of the integers
Represents vectors by R^n elements</p>
<dl class="class">
<dt id="odl.space.sequence.TruncationDiscretization.Vector">
<em class="property">class </em><code class="descname">Vector</code><span class="sig-paren">(</span><em>space</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/sequence.html#TruncationDiscretization.Vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.sequence.TruncationDiscretization.Vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">odl.space.cartesian.Vector</span></code></p>
</dd></dl>

<dl class="method">
<dt id="odl.space.sequence.TruncationDiscretization.element">
<code class="descclassname">TruncationDiscretization.</code><code class="descname">element</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/sequence.html#TruncationDiscretization.element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.sequence.TruncationDiscretization.element" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odl.space.sequence.TruncationDiscretization.integrate">
<code class="descclassname">TruncationDiscretization.</code><code class="descname">integrate</code><span class="sig-paren">(</span><em>vector</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/sequence.html#TruncationDiscretization.integrate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.sequence.TruncationDiscretization.integrate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odl.space.sequence.TruncationDiscretization.points">
<code class="descclassname">TruncationDiscretization.</code><code class="descname">points</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/sequence.html#TruncationDiscretization.points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.sequence.TruncationDiscretization.points" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odl.space.sequence.TruncationDiscretization.zero">
<code class="descclassname">TruncationDiscretization.</code><code class="descname">zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/sequence.html#TruncationDiscretization.zero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.sequence.TruncationDiscretization.zero" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-odl.space.set">
<span id="odl-space-set-module"></span><h2>odl.space.set module<a class="headerlink" href="#module-odl.space.set" title="Permalink to this headline">¶</a></h2>
<p>General set structure as well as implementations of the most common sets.</p>
<dl class="class">
<dt id="odl.space.set.CartesianProduct">
<em class="property">class </em><code class="descclassname">odl.space.set.</code><code class="descname">CartesianProduct</code><span class="sig-paren">(</span><em>*sets</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#CartesianProduct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.CartesianProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.set.Set" title="odl.space.set.Set"><code class="xref py py-class docutils literal"><span class="pre">odl.space.set.Set</span></code></a></p>
<dl class="method">
<dt id="odl.space.set.CartesianProduct.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>point</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#CartesianProduct.contains"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.CartesianProduct.contains" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odl.space.set.CartesianProduct.equals">
<code class="descname">equals</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#CartesianProduct.equals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.CartesianProduct.equals" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odl.space.set.CartesianProduct.sets">
<code class="descname">sets</code><a class="headerlink" href="#odl.space.set.CartesianProduct.sets" title="Permalink to this definition">¶</a></dt>
<dd><p>The factors (sets) as a tuple.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odl.space.set.ComplexNumbers">
<em class="property">class </em><code class="descclassname">odl.space.set.</code><code class="descname">ComplexNumbers</code><a class="reference internal" href="_modules/odl/space/set.html#ComplexNumbers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.ComplexNumbers" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.set.Set" title="odl.space.set.Set"><code class="xref py py-class docutils literal"><span class="pre">odl.space.set.Set</span></code></a></p>
<p>The set of complex numbers.</p>
<dl class="method">
<dt id="odl.space.set.ComplexNumbers.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#ComplexNumbers.contains"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.ComplexNumbers.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if <cite>other</cite> is a complex number.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.ComplexNumbers.element">
<code class="descname">element</code><span class="sig-paren">(</span><em>inp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#ComplexNumbers.element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.ComplexNumbers.element" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a complex number from <cite>inp</cite> or from scratch.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.ComplexNumbers.equals">
<code class="descname">equals</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#ComplexNumbers.equals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.ComplexNumbers.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if <cite>other</cite> is a <cite>ComplexNumbers</cite> instance.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odl.space.set.Cube">
<em class="property">class </em><code class="descclassname">odl.space.set.</code><code class="descname">Cube</code><span class="sig-paren">(</span><em>begin</em>, <em>end</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#Cube"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.Cube" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.set.IntervalProd" title="odl.space.set.IntervalProd"><code class="xref py py-class docutils literal"><span class="pre">odl.space.set.IntervalProd</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="odl.space.set.EmptySet">
<em class="property">class </em><code class="descclassname">odl.space.set.</code><code class="descname">EmptySet</code><a class="reference internal" href="_modules/odl/space/set.html#EmptySet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.EmptySet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.set.Set" title="odl.space.set.Set"><code class="xref py py-class docutils literal"><span class="pre">odl.space.set.Set</span></code></a></p>
<p>The empty set.</p>
<dl class="method">
<dt id="odl.space.set.EmptySet.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#EmptySet.contains"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.EmptySet.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if <cite>other</cite> is None.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.EmptySet.element">
<code class="descname">element</code><span class="sig-paren">(</span><em>inp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#EmptySet.element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.EmptySet.element" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an element, only possible if <cite>inp</cite> is <cite>None</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.EmptySet.equals">
<code class="descname">equals</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#EmptySet.equals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.EmptySet.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if <cite>other</cite> is an <cite>EmptySet</cite> instance.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odl.space.set.Integers">
<em class="property">class </em><code class="descclassname">odl.space.set.</code><code class="descname">Integers</code><a class="reference internal" href="_modules/odl/space/set.html#Integers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.Integers" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.set.Set" title="odl.space.set.Set"><code class="xref py py-class docutils literal"><span class="pre">odl.space.set.Set</span></code></a></p>
<p>The set of integers.</p>
<dl class="method">
<dt id="odl.space.set.Integers.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#Integers.contains"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.Integers.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if <cite>other</cite> is an integer.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.Integers.element">
<code class="descname">element</code><span class="sig-paren">(</span><em>inp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#Integers.element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.Integers.element" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an integer from <cite>inp</cite> or from scratch.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.Integers.equals">
<code class="descname">equals</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#Integers.equals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.Integers.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if <cite>other</cite> is an <cite>Integers</cite> instance.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odl.space.set.Interval">
<em class="property">class </em><code class="descclassname">odl.space.set.</code><code class="descname">Interval</code><span class="sig-paren">(</span><em>begin</em>, <em>end</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#Interval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.Interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.set.IntervalProd" title="odl.space.set.IntervalProd"><code class="xref py py-class docutils literal"><span class="pre">odl.space.set.IntervalProd</span></code></a></p>
<p>The set of real numbers in the interval [begin, end]</p>
<dl class="attribute">
<dt id="odl.space.set.Interval.length">
<code class="descname">length</code><a class="headerlink" href="#odl.space.set.Interval.length" title="Permalink to this definition">¶</a></dt>
<dd><p>The length of this interval</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odl.space.set.IntervalProd">
<em class="property">class </em><code class="descclassname">odl.space.set.</code><code class="descname">IntervalProd</code><span class="sig-paren">(</span><em>begin</em>, <em>end</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#IntervalProd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.IntervalProd" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.set.Set" title="odl.space.set.Set"><code class="xref py py-class docutils literal"><span class="pre">odl.space.set.Set</span></code></a></p>
<p>An n-dimensional rectangular box.</p>
<p>An IntervalProd is a Cartesian product of N intervals, i.e. an
N-dimensional rectangular box aligned with the coordinate axes
as a subset of R^n.</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="24%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>begin</cite></td>
<td><cite>numpy.ndarray</cite>
or <cite>float</cite></td>
<td>(Vector of) leftmost interval point(s)</td>
</tr>
<tr class="row-odd"><td><cite>end</cite></td>
<td><cite>numpy.ndarray</cite>
or <cite>float</cite></td>
<td>(Vector of) rightmost interval
point(s)</td>
</tr>
<tr class="row-even"><td><cite>dim</cite></td>
<td><cite>int</cite></td>
<td>Number of axes</td>
</tr>
<tr class="row-odd"><td><cite>truedim</cite></td>
<td><cite>int</cite></td>
<td>Number of non-degenerate axes, i.e.
where <cite>begin != end</cite></td>
</tr>
<tr class="row-even"><td><cite>sizes</cite></td>
<td><cite>numpy.ndarray</cite>
or <cite>float</cite></td>
<td>(Vector of) interval length(s)</td>
</tr>
<tr class="row-odd"><td><cite>volume</cite></td>
<td><cite>float</cite></td>
<td><cite>dim</cite>-dimensional measure</td>
</tr>
<tr class="row-even"><td><cite>midpoint</cite></td>
<td><cite>numpy.ndarray</cite>
or <cite>float</cite></td>
<td>Vector of interval midpoint(s)</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="24%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Signature</th>
<th class="head">Return type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>equals(other,
tol=0.0)</cite></td>
<td><cite>boolean</cite></td>
<td>Test if <cite>other</cite> is equal to
this interval product.</td>
</tr>
<tr class="row-odd"><td><cite>contains(other,
tol=0.0)</cite></td>
<td><cite>boolean</cite></td>
<td>Test if <cite>other</cite> is contained
in this interval product.</td>
</tr>
<tr class="row-even"><td><cite>measure(dim=None)</cite></td>
<td><cite>float</cite></td>
<td>Return the <cite>dim</cite>-dimensional
measure of this interval
product.</td>
</tr>
<tr class="row-odd"><td><cite>dist(point,
ord=2.0)</cite></td>
<td><cite>float</cite></td>
<td>Return the distance in
<cite>ord</cite>-norm between <cite>point</cite>
and this interval product.</td>
</tr>
<tr class="row-even"><td><cite>collapse(indcs,
vals)</cite></td>
<td><cite>IntervalProd</cite></td>
<td>Return the interval product
where the intervals at
<cite>indcs</cite> are collapsed to
single values <cite>vals</cite>.</td>
</tr>
<tr class="row-odd"><td><cite>insert(other,
index)</cite></td>
<td><cite>IntervalProd</cite></td>
<td>Return the interval product
wher <cite>other</cite> has been
before <cite>index</cite>.</td>
</tr>
<tr class="row-even"><td><cite>corners(order=&#8217;C&#8217;)</cite></td>
<td><cite>numpy.ndarray</cite></td>
<td>Return the corner points
of this interval product
in a single array.</td>
</tr>
<tr class="row-odd"><td><cite>uniform_sampling(
num_nodes,
as_midp=False)</cite></td>
<td><cite>RegularGrid</cite></td>
<td>Create a regular grid by
sampling this interval
product at <cite>num_nodes</cite>
equidistant nodes (per
axis).</td>
</tr>
</tbody>
</table>
<p><cite>RegularGrid</cite> is defined in <cite>odl.discr.grid</cite>.</p>
<dl class="attribute">
<dt id="odl.space.set.IntervalProd.begin">
<code class="descname">begin</code><a class="headerlink" href="#odl.space.set.IntervalProd.begin" title="Permalink to this definition">¶</a></dt>
<dd><p>The left interval boundary/boundaries.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.IntervalProd.collapse">
<code class="descname">collapse</code><span class="sig-paren">(</span><em>indcs</em>, <em>values</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#IntervalProd.collapse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.IntervalProd.collapse" title="Permalink to this definition">¶</a></dt>
<dd><p>Partly collapse the interval product to single values.</p>
<p>Note that no changes are made in-place.</p>
<dl class="docutils">
<dt>indcs <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of ints</span></dt>
<dd>The indices of the dimensions along which to collapse</dd>
<dt>values <span class="classifier-delimiter">:</span> <span class="classifier">float or array-like</span></dt>
<dd>The values to which to collapse. Must have the same
lenght as &#8216;indcs&#8217;. Values must lie within the interval
boundaries.</dd>
</dl>
<p>The collapsed IntervalProd</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span> <span class="o">=</span> <span class="n">IntervalProd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">IntervalProd([-1.0, 0.0, 2.0], [-0.5, 0.0, 3.0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">collapse</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">])</span>
<span class="go">IntervalProd([-1.0, 0.0, 2.5], [-0.5, 0.0, 2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">collapse</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">&#39;values&#39; not within interval boundaries ([3.5] &gt;</span>
<span class="go">[3.0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.IntervalProd.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>point</em>, <em>tol=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#IntervalProd.contains"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.IntervalProd.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if a point is contained.</p>
<dl class="docutils">
<dt>point <span class="classifier-delimiter">:</span> <span class="classifier">array-like or float</span></dt>
<dd>The point to be tested. Its length must be equal
to the set&#8217;s dimension. In the 1d case, &#8216;point&#8217;
can be given as a float.</dd>
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd>The maximum allowed distance in &#8216;inf&#8217;-norm between the
point and the set.
Default: 0.0</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span> <span class="o">=</span> <span class="n">IntervalProd</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">contains</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">])</span>  <span class="c"># Num error</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">contains</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">],</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-15</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.IntervalProd.contains_grid">
<code class="descname">contains_grid</code><span class="sig-paren">(</span><em>grid</em>, <em>tol=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#IntervalProd.contains_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.IntervalProd.contains_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if a grid is contained.</p>
<dl class="docutils">
<dt>grid <span class="classifier-delimiter">:</span> <span class="classifier"><cite>TensorGrid</cite></span></dt>
<dd>The grid to be tested</dd>
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd>The maximum allowed distance in &#8216;inf&#8217;-norm between the
grid points and the set.
Default: 0.0</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">odl.discr.grid</span> <span class="kn">import</span> <span class="n">TensorGrid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span> <span class="o">=</span> <span class="n">IntervalProd</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">TensorGrid</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">contains_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">TensorGrid</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">contains_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">TensorGrid</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.4</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">contains_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">contains_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.IntervalProd.corners">
<code class="descname">corners</code><span class="sig-paren">(</span><em>order=u'C'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#IntervalProd.corners"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.IntervalProd.corners" title="Permalink to this definition">¶</a></dt>
<dd><p>The corner points in a single array.</p>
<dl class="docutils">
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">&#8216;C&#8217; or &#8216;F&#8217;</span></dt>
<dd>The ordering of the axes in which the corners appear in
the output.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd>The size of the array is 2^m x dim, where m is the number of
non-degenerate axes, i.e. the corners are stored as rows.</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span> <span class="o">=</span> <span class="n">IntervalProd</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">corners</span><span class="p">()</span>
<span class="go">array([[-1. ,  2. ,  0. ],</span>
<span class="go">       [-1. ,  2. ,  0.5],</span>
<span class="go">       [-1. ,  3. ,  0. ],</span>
<span class="go">       [-1. ,  3. ,  0.5],</span>
<span class="go">       [-0.5,  2. ,  0. ],</span>
<span class="go">       [-0.5,  2. ,  0.5],</span>
<span class="go">       [-0.5,  3. ,  0. ],</span>
<span class="go">       [-0.5,  3. ,  0.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">corners</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([[-1. ,  2. ,  0. ],</span>
<span class="go">       [-0.5,  2. ,  0. ],</span>
<span class="go">       [-1. ,  3. ,  0. ],</span>
<span class="go">       [-0.5,  3. ,  0. ],</span>
<span class="go">       [-1. ,  2. ,  0.5],</span>
<span class="go">       [-0.5,  2. ,  0.5],</span>
<span class="go">       [-1. ,  3. ,  0.5],</span>
<span class="go">       [-0.5,  3. ,  0.5]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.set.IntervalProd.dim">
<code class="descname">dim</code><a class="headerlink" href="#odl.space.set.IntervalProd.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of intervals in the product.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.IntervalProd.dist">
<code class="descname">dist</code><span class="sig-paren">(</span><em>point</em>, <em>ord=2.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#IntervalProd.dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.IntervalProd.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the distance to a point.</p>
<dl class="docutils">
<dt>point <span class="classifier-delimiter">:</span> <span class="classifier">array-like or float</span></dt>
<dd>The point. Its length must be equal to the set&#8217;s
dimension. In the 1d case, &#8216;point&#8217; can be given as a
float.</dd>
<dt>ord <span class="classifier-delimiter">:</span> <span class="classifier">non-zero int or float(&#8216;inf&#8217;), optional</span></dt>
<dd>The order of the norm (see numpy.linalg.norm).
Default: 2.0</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span> <span class="o">=</span> <span class="n">IntervalProd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">dist</span><span class="p">([</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">5.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">dist</span><span class="p">([</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="nb">ord</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">))</span>
<span class="go">4.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.IntervalProd.element">
<code class="descname">element</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#IntervalProd.element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.IntervalProd.element" title="Permalink to this definition">¶</a></dt>
<dd><p>An arbitrary element, the midpoint.</p>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.set.IntervalProd.end">
<code class="descname">end</code><a class="headerlink" href="#odl.space.set.IntervalProd.end" title="Permalink to this definition">¶</a></dt>
<dd><p>The right interval boundary/boundaries.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.IntervalProd.equals">
<code class="descname">equals</code><span class="sig-paren">(</span><em>other</em>, <em>tol=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#IntervalProd.equals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.IntervalProd.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if another set is equal to the current one.</p>
<dl class="docutils">
<dt>other <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd>The object to be tested.</dd>
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd>The maximum allowed difference in &#8216;inf&#8217;-norm between the
interval endpoints.
Default: 0.0</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox1</span> <span class="o">=</span> <span class="n">IntervalProd</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox2</span> <span class="o">=</span> <span class="n">IntervalProd</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox1</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">rbox2</span><span class="p">)</span>  <span class="c"># Num error</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox1</span> <span class="o">==</span> <span class="n">rbox2</span>  <span class="c"># Equivalent to rbox1.equals(rbox2)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox1</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">rbox2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-15</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.IntervalProd.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>other</em>, <em>index</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#IntervalProd.insert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.IntervalProd.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert another IntervalProd before the given index.</p>
<p>The given IntervalProd (dim=m) is inserted into the current
one (dim=n) before the given index, resulting in a new
IntervalProd of dimension n+m.
Note that no changes are made in-place.</p>
<dl class="docutils">
<dt>other <span class="classifier-delimiter">:</span> <span class="classifier">IntervalProd, float or array-like</span></dt>
<dd>The IntervalProd to be inserted. A float or array a is
treated as an IntervalProd(a, a).</dd>
<dt>index <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>The index of the dimension before which &#8216;other&#8217; is to
be inserted. Must fulfill 0 &lt;= index &lt;= dim.</dd>
</dl>
<p>The enlarged IntervalProd</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span> <span class="o">=</span> <span class="n">IntervalProd</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox2</span> <span class="o">=</span> <span class="n">IntervalProd</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">rbox2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">IntervalProd([-1.0, 0.0, 0.0, 2.0], [-0.5, 1.0, 0.0, 3.0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">insert</span><span class="p">([</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">IntervalProd([-1.0, 2.0, -1.0, 0.0], [-0.5, 3.0, -1.0, 0.0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">rbox</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.IntervalProd.measure">
<code class="descname">measure</code><span class="sig-paren">(</span><em>dim=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#IntervalProd.measure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.IntervalProd.measure" title="Permalink to this definition">¶</a></dt>
<dd><p>The (Lebesgue) measure of the IntervalProd instance.</p>
<dl class="docutils">
<dt>dim <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The dimension of the measure to apply.
Default: truedim</dd>
</dl>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span> <span class="o">=</span> <span class="n">IntervalProd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">measure</span><span class="p">()</span>
<span class="go">3.75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">rbox</span><span class="o">.</span><span class="n">volume</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">measure</span><span class="p">()</span> <span class="o">==</span> <span class="n">rbox</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">volume</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.set.IntervalProd.midpoint">
<code class="descname">midpoint</code><a class="headerlink" href="#odl.space.set.IntervalProd.midpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>The midpoint of the interval product.</p>
<p>If dim == 1, a float is returned, otherwise an array.</p>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.set.IntervalProd.size">
<code class="descname">size</code><a class="headerlink" href="#odl.space.set.IntervalProd.size" title="Permalink to this definition">¶</a></dt>
<dd><p>The interval length per axis.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.IntervalProd.squeeze">
<code class="descname">squeeze</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#IntervalProd.squeeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.IntervalProd.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the degenerate dimensions.</p>
<p>Note that no changes are made in-place.</p>
<p>The squeezed IntervalProd</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span> <span class="o">=</span> <span class="n">IntervalProd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">collapse</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
<span class="go">IntervalProd([-1.0, 2.0], [-0.5, 3.0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">collapse</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
<span class="go">IntervalProd([-1.0], [-0.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span><span class="o">.</span><span class="n">collapse</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
<span class="go">IntervalProd([], [])</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.set.IntervalProd.truedim">
<code class="descname">truedim</code><a class="headerlink" href="#odl.space.set.IntervalProd.truedim" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of non-degenerate (zero-length) intervals.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.IntervalProd.uniform_sampling">
<code class="descname">uniform_sampling</code><span class="sig-paren">(</span><em>num_nodes</em>, <em>as_midp=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#IntervalProd.uniform_sampling"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.IntervalProd.uniform_sampling" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce equispaced nodes, a RegularGrid.</p>
<dl class="docutils">
<dt>num_nodes <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of int&#8217;s</span></dt>
<dd>The number of nodes per axis. For dim=1, a single int may
be given. All entries must be positive. Entries
corresponding to degenerate axes must be equal to 1.</dd>
<dt>as_midp <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd>If True, the midpoints of an interval partition will be
returned, which excludes the endpoints. Otherwise,
equispaced nodes including the endpoints are generated.
Note that the resulting strides are different.
Default: False.</dd>
</dl>
<p>sampling : grid.RegularGrid</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rbox</span> <span class="o">=</span> <span class="n">IntervalProd</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">rbox</span><span class="o">.</span><span class="n">uniform_sampling</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span><span class="o">.</span><span class="n">coord_vectors</span>
<span class="go">(array([-1. , -0.5]), array([ 2.  ,  2.25,  2.5 ,  2.75,  3.  ]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">rbox</span><span class="o">.</span><span class="n">uniform_sampling</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">as_midp</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span><span class="o">.</span><span class="n">coord_vectors</span>
<span class="go">(array([-0.875, -0.625]), array([ 2.1,  2.3,  2.5,  2.7,  2.9]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.set.IntervalProd.volume">
<code class="descname">volume</code><a class="headerlink" href="#odl.space.set.IntervalProd.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>The &#8216;dim&#8217;-dimensional volume of this IntervalProd.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odl.space.set.RealNumbers">
<em class="property">class </em><code class="descclassname">odl.space.set.</code><code class="descname">RealNumbers</code><a class="reference internal" href="_modules/odl/space/set.html#RealNumbers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.RealNumbers" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.set.Set" title="odl.space.set.Set"><code class="xref py py-class docutils literal"><span class="pre">odl.space.set.Set</span></code></a></p>
<p>The set of real numbers.</p>
<dl class="method">
<dt id="odl.space.set.RealNumbers.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#RealNumbers.contains"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.RealNumbers.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if <cite>other</cite> is a real number.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.RealNumbers.element">
<code class="descname">element</code><span class="sig-paren">(</span><em>inp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#RealNumbers.element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.RealNumbers.element" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a real number from <cite>inp</cite> or from scratch.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.RealNumbers.equals">
<code class="descname">equals</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#RealNumbers.equals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.RealNumbers.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if <cite>other</cite> is a <cite>RealNumbers</cite> instance.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odl.space.set.Rectangle">
<em class="property">class </em><code class="descclassname">odl.space.set.</code><code class="descname">Rectangle</code><span class="sig-paren">(</span><em>begin</em>, <em>end</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#Rectangle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.Rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.set.IntervalProd" title="odl.space.set.IntervalProd"><code class="xref py py-class docutils literal"><span class="pre">odl.space.set.IntervalProd</span></code></a></p>
<dl class="attribute">
<dt id="odl.space.set.Rectangle.area">
<code class="descname">area</code><a class="headerlink" href="#odl.space.set.Rectangle.area" title="Permalink to this definition">¶</a></dt>
<dd><p>The area of this triangle</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odl.space.set.Set">
<em class="property">class </em><code class="descclassname">odl.space.set.</code><code class="descname">Set</code><a class="reference internal" href="_modules/odl/space/set.html#Set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.Set" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">future.types.newobject.newobject</span></code></p>
<p>An abstract set.</p>
<dl class="method">
<dt id="odl.space.set.Set.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#Set.contains"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.Set.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if other is a member of self</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.Set.element">
<code class="descname">element</code><span class="sig-paren">(</span><em>inp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#Set.element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.Set.element" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an element from <cite>inp</cite> or from scratch.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.Set.equals">
<code class="descname">equals</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#Set.equals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.Set.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Test two sets for equality</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odl.space.set.UniversalSet">
<em class="property">class </em><code class="descclassname">odl.space.set.</code><code class="descname">UniversalSet</code><a class="reference internal" href="_modules/odl/space/set.html#UniversalSet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.UniversalSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.set.Set" title="odl.space.set.Set"><code class="xref py py-class docutils literal"><span class="pre">odl.space.set.Set</span></code></a></p>
<p>The set of all sets.</p>
<p>Forget about set theory for a moment :-)</p>
<dl class="method">
<dt id="odl.space.set.UniversalSet.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#UniversalSet.contains"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.UniversalSet.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>True</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.set.UniversalSet.equals">
<code class="descname">equals</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/set.html#UniversalSet.equals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.set.UniversalSet.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if <cite>other</cite> is a <cite>UniversalSet</cite> instance.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-odl.space.space">
<span id="odl-space-space-module"></span><h2>odl.space.space module<a class="headerlink" href="#module-odl.space.space" title="Permalink to this headline">¶</a></h2>
<p>Abstract vector spaces.</p>
<p>The classes in this module represent abstract mathematical concepts
of vector spaces. They cannot be used directly but are rather intended
to be subclassed by concrete space implementations. The spaces
provide default implementations of the most important vector space
operations. See the documentation of the respective classes for more
details.</p>
<div class="section" id="class-descriptions">
<h3>Class descriptions<a class="headerlink" href="#class-descriptions" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="19%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Class name</th>
<th class="head">Direct
ancestors</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>LinearSpace</cite></td>
<td><cite>Set</cite></td>
<td><strong>Abstract class.</strong> A vector space over
a field (real or complex numbers)
defining a vector-vector addition and a
scalar-vector multiplication with
certain properties. See the article
<a href="#id30"><span class="problematic" id="id31">`Vector space`_</span></a> on Wikipedia for further
information.</td>
</tr>
<tr class="row-odd"><td><cite>MetricSpace</cite></td>
<td><cite>LinearSpace</cite></td>
<td><strong>Abstract class.</strong> A vector space with
a metric, i.e. a <cite>dist</cite> function
measuring the distance between two
vectors.</td>
</tr>
<tr class="row-even"><td><cite>NormedSpace</cite></td>
<td><cite>MetricSpace</cite></td>
<td><strong>Abstract class.</strong> A metric space with
a <cite>norm</cite> function measuring the length
a vector. The <cite>dist</cite> function is induced
by the norm as
<cite>dist(x, y) = norm(x - y)</cite>.</td>
</tr>
<tr class="row-odd"><td><cite>HilbertSpace</cite></td>
<td><cite>NormedSpace</cite></td>
<td><strong>Abstract class.</strong> A normed space with
an inner product measuring angles
between vectors with unit length. The
<cite>norm</cite> function is induced by the inner
product by the according to
<cite>norm(x) = inner(x, x)</cite>.</td>
</tr>
<tr class="row-even"><td><cite>Algebra</cite></td>
<td><cite>LinearSpace</cite></td>
<td><strong>Abstract class.</strong> A linear space with
a vector-vector multiplication under
which the space is closed. See the
<a class="reference external" href="https://en.wikipedia.org/wiki/Associative_algebra">Algebra</a> article on Wikipedia for
further information. (Note that we
assume commutativity and unitality.)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="see-also">
<h3>See also<a class="headerlink" href="#see-also" title="Permalink to this headline">¶</a></h3>
<p>The <cite>Set</cite> class is defined in <cite>odl.space.set</cite>.</p>
<dl class="class">
<dt id="odl.space.space.LinearSpace">
<em class="property">class </em><code class="descclassname">odl.space.space.</code><code class="descname">LinearSpace</code><a class="reference internal" href="_modules/odl/space/space.html#LinearSpace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.space.LinearSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odl.space.set.Set" title="odl.space.set.Set"><code class="xref py py-class docutils literal"><span class="pre">odl.space.set.Set</span></code></a></p>
<p>Abstract linear vector space.</p>
<p>Its elements are represented as instances of the inner
<cite>LinearSpace.Vector</cite> class.</p>
<p>The concept of linear vector spaces in ODL is largely inspired by
the <a class="reference external" href="http://www.trip.caam.rice.edu/software/rvl/rvl/doc/html/">Rice Vector Library</a> (RVL).</p>
<p>The abstract <cite>LinearSpace</cite> class is intended for quick prototyping.
It has a number of abstract methods which must be overridden by a
subclass. On the other hand, it provides automatic error checking
and numerous attributes and methods for convenience.</p>
<p>In the following, the abstract methods are explained in detail.</p>
<p>This public method is the factory for the inner
<cite>LinearSpace.Vector</cite> class. It creates a new element of the space,
either from scratch or from an existing data container. In the
simplest possible case, it just delegates the construction to the
<cite>Vector</cite> class.</p>
<p>If no data is provided, the new element is <strong>merely allocated, not
initialized</strong>, thus it can contain <em>any</em> value.</p>
<dl class="docutils">
<dt><strong>Parameters:</strong></dt>
<dd><dl class="first last docutils">
<dt><cite>inp</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>object</cite>, optional</span></dt>
<dd>A container for values for the element initialization</dd>
</dl>
</dd>
<dt><strong>Returns:</strong></dt>
<dd><dl class="first last docutils">
<dt><cite>element</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>LinearSpace.Vector</cite></span></dt>
<dd>The new vector.</dd>
</dl>
</dd>
</dl>
<p>This private method is the raw implementation (i.e. no error
checking) of the linear combination <cite>z &lt;&#8211; a * x + b * y</cite>.
<cite>_lincomb</cite> and its public counterpart <cite>lincomb</cite> are used to cover
a range of convenience functions, see below.</p>
<dl class="docutils">
<dt><strong>Parameters:</strong></dt>
<dd><dl class="first last docutils">
<dt><cite>z</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>LinearSpace.Vector</cite></span></dt>
<dd>Element to which the result of the computation is written</dd>
<dt><cite>a</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>LinearSpace.field</cite> element</span></dt>
<dd>Multiplicative scalar factor for input vector <cite>x</cite></dd>
<dt><cite>x</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>LinearSpace.Vector</cite></span></dt>
<dd>First input vector</dd>
<dt><cite>b</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>LinearSpace.field</cite> element</span></dt>
<dd>Multiplicative scalar factor for input vector <cite>y</cite></dd>
<dt><cite>y</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>LinearSpace.Vector</cite></span></dt>
<dd>Second input vector</dd>
</dl>
</dd>
</dl>
<p><strong>Returns:</strong> <cite>None</cite></p>
<dl class="docutils">
<dt><strong>Requirements:</strong></dt>
<dd><ul class="first last simple">
<li>Aliasing of <cite>x</cite>, <cite>y</cite> and <cite>z</cite> <strong>must</strong> be allowed.</li>
<li>The input vectors <cite>x</cite> and <cite>y</cite> <strong>must not</strong> be modified.</li>
<li>The initial state of the output vector <cite>z</cite> <strong>must not</strong>
influence the result.</li>
</ul>
</dd>
</dl>
<p>The public attribute determining the type of scalars which
underlie the space. Can be either <cite>RealNumbers</cite> or
<cite>ComplexNumbers</cite> (see <cite>odl.space.set</cite>).</p>
<p>Must be implemented as a <cite>&#64;property</cite> to make it immutable.</p>
<p><cite>LinearSpace</cite> inherits this abstract method from <cite>Set</cite>. Its
purpose is to check two <cite>LinearSpace</cite> instances for equality.</p>
<dl class="docutils">
<dt><strong>Parameters:</strong></dt>
<dd><dl class="first last docutils">
<dt><cite>other</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>object</cite></span></dt>
<dd>The object to compare to.</dd>
</dl>
</dd>
<dt><strong>Returns:</strong></dt>
<dd><dl class="first last docutils">
<dt><cite>equals</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>boolean</cite></span></dt>
<dd><cite>True</cite> if <cite>other</cite> is the same <cite>LinearSpace</cite>, <cite>False</cite>
otherwise.</dd>
</dl>
</dd>
</dl>
<p>A raw (not type-checking) private method measuring the distance
between two vectors <cite>x</cite> and <cite>y</cite>.</p>
<p>A space with a distance is called a Metric Space.</p>
<dl class="docutils">
<dt><strong>Parameters:</strong></dt>
<dd><dl class="first last docutils">
<dt><cite>x</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>object</cite></span></dt>
<dd>The first vector</dd>
<dt><cite>y</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>object</cite></span></dt>
<dd>The second vector</dd>
</dl>
</dd>
<dt><strong>Returns:</strong></dt>
<dd><dl class="first last docutils">
<dt><cite>distance</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>RealNumber</cite></span></dt>
<dd>The distance between <cite>x</cite> and <cite>y</cite>, measured in the space&#8217;s
metric</dd>
</dl>
</dd>
<dt><strong>Requirements:</strong></dt>
<dd><ul class="first last simple">
<li><cite>_dist(x, y) == _dist(y, x)</cite></li>
<li><cite>_dist(x, y) &lt;= _dist(x, z) + _dist(z, y)</cite></li>
<li><cite>_dist(x, y) &gt;= 0</cite></li>
<li><cite>_dist(x, y) == 0</cite> (approx.) if and only if <cite>x == y</cite> (approx.)</li>
</ul>
</dd>
</dl>
<p>A raw (not type-checking) private method measuring the length of a
space element <cite>x</cite>.</p>
<p>A space with a norm is called a <cite>Normed Space</cite>.</p>
<dl class="docutils">
<dt><strong>Parameters:</strong></dt>
<dd><dl class="first last docutils">
<dt><cite>x</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>object</cite></span></dt>
<dd>The vector to measure</dd>
</dl>
</dd>
<dt><strong>Returns:</strong></dt>
<dd><dl class="first last docutils">
<dt><cite>norm</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>RealNumber</cite></span></dt>
<dd>The length of <cite>x</cite> as measured in the space&#8217;s metric</dd>
</dl>
</dd>
<dt><strong>Requirements:</strong></dt>
<dd><ul class="first last simple">
<li><cite>_norm(s * x) = |s| * _norm(x)</cite> for any scalar <cite>s</cite></li>
<li><cite>_norm(x + y) &lt;= _norm(x) + _norm(y)</cite></li>
<li><cite>_norm(x) &gt;= 0</cite></li>
<li><cite>_norm(x) == 0</cite> (approx.) if and only if <cite>x == 0</cite> (approx.)</li>
</ul>
</dd>
</dl>
<p>A <cite>Normed Space</cite> is a <cite>Metric Space</cite> with the distance function
<cite>_dist(x, y) = _norm(x - y)</cite>.</p>
<p>A raw (not type-checking) private method calculating the inner
product of two space elements <cite>x</cite> and <cite>y</cite>.</p>
<dl class="docutils">
<dt><strong>Parameters:</strong></dt>
<dd><dl class="first last docutils">
<dt><cite>x</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>object</cite></span></dt>
<dd>The first vector</dd>
<dt><cite>y</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>object</cite></span></dt>
<dd>The second vector</dd>
</dl>
</dd>
<dt><strong>Returns:</strong></dt>
<dd><dl class="first last docutils">
<dt><cite>inner</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>space.field</cite> element</span></dt>
<dd>The inner product of <cite>x</cite> and <cite>y</cite></dd>
</dl>
</dd>
<dt><strong>Requirements:</strong></dt>
<dd><ul class="first last simple">
<li><cite>_inner(x, y) == _inner(y, x)^*</cite> with &#8216;*&#8217; = complex conjugation</li>
<li><cite>_inner(s * x, y) == s * _inner(x, y)</cite> for <cite>s</cite> scalar</li>
<li><cite>_inner(x + z, y) == _inner(x, y) + _inner(z, y)</cite></li>
<li><cite>_inner(x, x) == 0</cite> (approx.) if and only if <cite>x == 0</cite> (approx.)</li>
</ul>
</dd>
</dl>
<p>A <cite>HilbertSpace</cite> is a <cite>NormedSpace</cite> with the norm function
<cite>_norm(x) = sqrt(_inner(x, x))</cite>, and in consequence also a
<cite>MetricSpace</cite> with the distance function
<cite>_dist(x, y) = _norm(x - y)</cite>.</p>
<p>A raw (not type-checking) private method multiplying two vectors
<cite>x</cite> and <cite>y</cite>.</p>
<dl class="docutils">
<dt><strong>Parameters:</strong></dt>
<dd><dl class="first last docutils">
<dt><cite>x</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>object</cite></span></dt>
<dd>First vector</dd>
<dt><cite>y</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>object</cite></span></dt>
<dd>Second vector, stores the final result</dd>
</dl>
</dd>
</dl>
<p><strong>Returns:</strong> <cite>None</cite></p>
<dl class="docutils">
<dt><strong>Requirements:</strong></dt>
<dd><ul class="first last">
<li><p class="first"><cite>y</cite> after <cite>_multiply(x, y)</cite> equals <cite>x</cite> after <cite>_multiply(y, x)</cite></p>
</li>
<li><dl class="first docutils">
<dt><a href="#id19"><span class="problematic" id="id20">`</span></a>_multiply(s * x, y) &lt;==&gt; y <a href="#id21"><span class="problematic" id="id22">*</span></a>= s; _multiply(x, y)  &lt;==&gt;</dt>
<dd><p class="first last">_multiply(x, y); y <a href="#id23"><span class="problematic" id="id24">*</span></a>= s` for <cite>s</cite> scalar</p>
</dd>
</dl>
</li>
<li><p class="first">There is a space element <cite>one</cite> with
<cite>x</cite> after <cite>_multiply(one, x)</cite> equals <cite>x</cite> equals <cite>one</cite>
after <cite>_multiply(x, one)</cite>.</p>
</li>
</ul>
</dd>
</dl>
<p>The above conditions on the multiplication make <cite>Algebra</cite> a
<em>unital commutative algebra</em> in the mathematical sense.</p>
<p><cite>LinearSpace</cite> provides several default methods for convenience
which use the abstract methods above. A subclass may override
them with own implementations.</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="0%" />
<col width="0%" />
<col width="2%" />
<col width="14%" />
<col width="0%" />
<col width="2%" />
<col width="11%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" colspan="3">Signature</th>
<th class="head" colspan="5">Return type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td colspan="3"><cite>lincomb(z, a,
x, b, y)</cite></td>
<td colspan="5"><cite>None</cite></td>
<td>Linear combination
<cite>z &lt;&#8211; a * x + b * y</cite>. Like
<cite>_lincomb()</cite>, but with type
checks.</td>
</tr>
<tr class="row-odd"><td colspan="3"><cite>zero()</cite></td>
<td colspan="5"><cite>LinearSpace.Vector</cite></td>
<td>Create a zero vector by first
issuing <cite>x = element()</cite> and
then
<cite>_lincomb(x, 0, x, 0, x)</cite></td>
</tr>
<tr class="row-even"><td colspan="9">Metric Space methods</td>
</tr>
<tr class="row-odd"><td colspan="9"><dl class="first last docutils">
<dt><cite>dist(x, y)`|`float</cite>     <a href="#id25"><span class="problematic" id="id26">|</span></a>Distance between two space elements.</dt>
<dd><div class="first last line-block">
<div class="line"><a href="#id27"><span class="problematic" id="id28">|</span></a>Like <cite>_dist()</cite>, but with type checks.</div>
</div>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td colspan="9">Normed Space methods</td>
</tr>
<tr class="row-odd"><td colspan="2"><cite>norm(x)</cite></td>
<td colspan="4"><cite>float</cite></td>
<td colspan="3">Length of a space element. Like
<cite>_norm()</cite>, but with type checks.</td>
</tr>
<tr class="row-even"><td colspan="9">Hilbert Space methods</td>
</tr>
<tr class="row-odd"><td colspan="2"><cite>inner(x, y)</cite></td>
<td colspan="4"><cite>field</cite>
element</td>
<td colspan="3">Inner product of two space elements.
Like <cite>_inner()</cite>, but with type
checks.</td>
</tr>
<tr class="row-even"><td colspan="9">Algebra       methods</td>
</tr>
<tr class="row-odd"><td colspan="4"><cite>multiply(x, y)</cite></td>
<td colspan="3"><cite>None</cite></td>
<td colspan="2">Multiplication of two space
elements. Like <cite>_multiply()</cite>, but
with type checks.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="28%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Signature</th>
<th class="head">Provides syntax</th>
<th class="head">Implementation</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>__eq__(other)</cite></td>
<td><cite>self == other</cite></td>
<td><cite>equals(other)</cite></td>
</tr>
<tr class="row-odd"><td><cite>__ne__(other)</cite></td>
<td><cite>self != other</cite></td>
<td><cite>not equals(other)</cite></td>
</tr>
<tr class="row-even"><td><cite>__contains__(other)</cite></td>
<td><cite>other in self</cite></td>
<td><cite>contains(other)</cite></td>
</tr>
</tbody>
</table>
<p>See Wikipedia&#8217;s <a href="#id32"><span class="problematic" id="id33">`Vector space`_</span></a> article for a mathematical
overview.</p>
<dl class="class">
<dt id="odl.space.space.LinearSpace.Vector">
<em class="property">class </em><code class="descname">Vector</code><span class="sig-paren">(</span><em>space</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/space.html#LinearSpace.Vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.space.LinearSpace.Vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">future.types.newobject.newobject</span></code></p>
<p>Abstract <cite>LinearSpace</cite> element.</p>
<p>Not intended for creation of vectors, use the space&#8217;s
<cite>element()</cite> method instead.</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="22%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>space</cite></td>
<td><cite>LinearSpace</cite></td>
<td>The space to which this vector belongs</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="0%" />
<col width="18%" />
<col width="16%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" colspan="2">Signature</th>
<th class="head" colspan="2">Return type</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td colspan="2"><cite>assign(other)</cite></td>
<td colspan="2"><cite>None</cite></td>
<td>Copy the values of
<cite>other</cite> to this vector.</td>
</tr>
<tr class="row-odd"><td colspan="2"><cite>copy()</cite></td>
<td colspan="2"><cite>LinearSpace.Vector</cite></td>
<td>Create a (deep) copy of
this vector.</td>
</tr>
<tr class="row-even"><td colspan="2"><cite>lincomb(a, x,
b=None, y=None)</cite></td>
<td colspan="2"><cite>None</cite></td>
<td>Linear combination
<cite>a * x + b * y</cite>, stored
in this vector.</td>
</tr>
<tr class="row-odd"><td colspan="2"><cite>set_zero()</cite></td>
<td colspan="2"><cite>None</cite></td>
<td>Multiply this vector
by zero.</td>
</tr>
<tr class="row-even"><td colspan="5">Metric space methods</td>
</tr>
<tr class="row-odd"><td><cite>equals(other)</cite></td>
<td colspan="2"><cite>boolean</cite></td>
<td colspan="2">Test if <cite>other</cite> is equal to this
vector. Implemented as
<cite>dist(other) == 0</cite>.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="27%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Signature</th>
<th class="head">Provides syntax</th>
<th class="head">Implementation</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>__iadd__(other)</cite></td>
<td><cite>self += other</cite></td>
<td><cite>lincomb(self, 1, self,
1, other)</cite></td>
</tr>
<tr class="row-odd"><td><cite>__isub__(other)</cite></td>
<td><cite>self -= other</cite></td>
<td><cite>lincomb(self, 1, self,
-1, other)</cite></td>
</tr>
<tr class="row-even"><td><cite>__imul__(scalar)</cite></td>
<td><cite>self *= scalar</cite></td>
<td><cite>lincomb(self, scalar,
self)</cite></td>
</tr>
<tr class="row-odd"><td><cite>__itruediv__
(scalar)</cite></td>
<td><cite>self /= scalar</cite></td>
<td><cite>__imul__(1.0 / scalar)</cite></td>
</tr>
<tr class="row-even"><td><cite>__idiv__(scalar)</cite></td>
<td><cite>self /= scalar</cite></td>
<td>same as <cite>__itruediv__</cite></td>
</tr>
<tr class="row-odd"><td><cite>__add__(other)</cite></td>
<td><cite>self + other</cite></td>
<td><cite>x = element()</cite>;
<cite>lincomb(x, 1, self, 1,
other)</cite></td>
</tr>
<tr class="row-even"><td><cite>__sub__(other)</cite></td>
<td><cite>self - other</cite></td>
<td><cite>x = element()</cite>;
<cite>lincomb(x, 1, self, -1,
other)</cite></td>
</tr>
<tr class="row-odd"><td><cite>__mul__(scalar)</cite></td>
<td><cite>self * scalar</cite></td>
<td><cite>x = element()</cite>;
<cite>lincomb(x, scalar,
self)</cite></td>
</tr>
<tr class="row-even"><td><cite>__rmul__(scalar)</cite></td>
<td><cite>scalar * self</cite></td>
<td><cite>__mul__(scalar)</cite></td>
</tr>
<tr class="row-odd"><td><cite>__truediv__
(scalar)</cite></td>
<td><cite>self /= scalar</cite></td>
<td><cite>__mul__(1.0 / scalar)</cite></td>
</tr>
<tr class="row-even"><td><cite>__div__(scalar)</cite></td>
<td><cite>self /= scalar</cite></td>
<td>same as <cite>__truediv__</cite></td>
</tr>
<tr class="row-odd"><td><cite>__pos__()</cite></td>
<td><cite>+self</cite></td>
<td><cite>copy()</cite></td>
</tr>
<tr class="row-even"><td><cite>__neg__()</cite></td>
<td><cite>-self</cite></td>
<td><cite>x = element()</cite>;
<cite>lincomb(x, -1, self)</cite></td>
</tr>
<tr class="row-odd"><td colspan="3">Metric space methods</td>
</tr>
<tr class="row-even"><td><cite>__eq__(other)</cite></td>
<td><cite>self == other</cite></td>
<td><cite>equals(other)</cite></td>
</tr>
<tr class="row-odd"><td><cite>__ne__(other)</cite></td>
<td><cite>self != other</cite></td>
<td><cite>not equals(other)</cite></td>
</tr>
</tbody>
</table>
<p>Note that <cite>lincomb</cite> and <cite>element</cite> refer to <cite>LinearSpace</cite>
methods.</p>
<dl class="method">
<dt id="odl.space.space.LinearSpace.Vector.assign">
<code class="descname">assign</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/space.html#LinearSpace.Vector.assign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.space.LinearSpace.Vector.assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign the values of other to this vector.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.space.LinearSpace.Vector.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/space.html#LinearSpace.Vector.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.space.LinearSpace.Vector.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an identical (deep) copy of this vector.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.space.LinearSpace.Vector.dist">
<code class="descname">dist</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/space.html#LinearSpace.Vector.dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.space.LinearSpace.Vector.dist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odl.space.space.LinearSpace.Vector.equals">
<code class="descname">equals</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/space.html#LinearSpace.Vector.equals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.space.LinearSpace.Vector.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Test two vectors for equality.</p>
<p>Two vectors are equal if their distance is 0</p>
<dl class="docutils">
<dt>other <span class="classifier-delimiter">:</span> <span class="classifier">MetricSpace.Vector</span></dt>
<dd>Vector in this space.</dd>
</dl>
<dl class="docutils">
<dt>equals <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>True if the vectors are equal, else false.</dd>
</dl>
<p>Equality is very sensitive to numerical errors, thus any
operations on a vector should be expected to break equality
testing.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">odl.space.cartesian</span> <span class="kn">import</span> <span class="n">Rn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Rn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="mf">0.1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="n">x</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="mf">0.1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="mf">0.3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">+</span><span class="n">x</span><span class="o">+</span><span class="n">x</span> <span class="o">==</span> <span class="n">z</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="odl.space.space.LinearSpace.Vector.inner">
<code class="descname">inner</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/space.html#LinearSpace.Vector.inner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.space.LinearSpace.Vector.inner" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odl.space.space.LinearSpace.Vector.lincomb">
<code class="descname">lincomb</code><span class="sig-paren">(</span><em>a</em>, <em>x</em>, <em>b=None</em>, <em>y=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/space.html#LinearSpace.Vector.lincomb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.space.LinearSpace.Vector.lincomb" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign a linear combination to this vector.</p>
<p>Implemented as <cite>space.lincomb(self, a, x, b, y)</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.space.LinearSpace.Vector.multiply">
<code class="descname">multiply</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/space.html#LinearSpace.Vector.multiply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.space.LinearSpace.Vector.multiply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odl.space.space.LinearSpace.Vector.norm">
<code class="descname">norm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/space.html#LinearSpace.Vector.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.space.LinearSpace.Vector.norm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odl.space.space.LinearSpace.Vector.set_zero">
<code class="descname">set_zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/space.html#LinearSpace.Vector.set_zero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.space.LinearSpace.Vector.set_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Set this vector to the zero vector.</p>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.space.LinearSpace.Vector.space">
<code class="descname">space</code><a class="headerlink" href="#odl.space.space.LinearSpace.Vector.space" title="Permalink to this definition">¶</a></dt>
<dd><p>The space this vector belongs to.</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="odl.space.space.LinearSpace.contains">
<code class="descclassname">LinearSpace.</code><code class="descname">contains</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/space.html#LinearSpace.contains"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.space.LinearSpace.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Test an object for membership in space.</p>
<dl class="docutils">
<dt>other <span class="classifier-delimiter">:</span> <span class="classifier"><cite>object</cite></span></dt>
<dd>The object to test for membership</dd>
</dl>
<dl class="docutils">
<dt>contains <span class="classifier-delimiter">:</span> <span class="classifier"><cite>bool</cite></span></dt>
<dd>True if <cite>other</cite> is a <cite>LinearSpace.Vector</cite> instance and
<cite>other.space</cite> is equal to this space.</dd>
</dl>
<p>This is the strict default where spaces must be equal.
Subclasses may choose to implement a less strict check.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.space.LinearSpace.dist">
<code class="descclassname">LinearSpace.</code><code class="descname">dist</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/space.html#LinearSpace.dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.space.LinearSpace.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the distance between two vectors.</p>
<dl class="docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">MetricSpace.Vector</span></dt>
<dd>The first element</dd>
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">MetricSpace.Vector</span></dt>
<dd>The second element</dd>
</dl>
<dl class="docutils">
<dt>dist <span class="classifier-delimiter">:</span> <span class="classifier">RealNumber</span></dt>
<dd>Distance between vectors</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="odl.space.space.LinearSpace.element">
<code class="descclassname">LinearSpace.</code><code class="descname">element</code><span class="sig-paren">(</span><em>inp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/space.html#LinearSpace.element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.space.LinearSpace.element" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an element from <cite>inp</cite> or from scratch.</p>
<p>If called without <cite>inp</cite> argument, an arbitrary element in the
space is generated without guarantee of its state.</p>
<dl class="docutils">
<dt>inp <span class="classifier-delimiter">:</span> <span class="classifier"><cite>object</cite>, optional</span></dt>
<dd>The input data from which to create the element</dd>
</dl>
<dl class="docutils">
<dt>element <span class="classifier-delimiter">:</span> <span class="classifier"><cite>LinearSpace.Vector</cite></span></dt>
<dd>A vector in this space</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="odl.space.space.LinearSpace.field">
<code class="descclassname">LinearSpace.</code><code class="descname">field</code><a class="headerlink" href="#odl.space.space.LinearSpace.field" title="Permalink to this definition">¶</a></dt>
<dd><p>The field of the vector space.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.space.LinearSpace.inner">
<code class="descclassname">LinearSpace.</code><code class="descname">inner</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/space.html#LinearSpace.inner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.space.LinearSpace.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the inner product of the vectors x and y</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.space.LinearSpace.lincomb">
<code class="descclassname">LinearSpace.</code><code class="descname">lincomb</code><span class="sig-paren">(</span><em>z</em>, <em>a</em>, <em>x</em>, <em>b=None</em>, <em>y=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/space.html#LinearSpace.lincomb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.space.LinearSpace.lincomb" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear combination of vectors.</p>
<p>Calculates</p>
<p>z = a*x
or if b and y are given
z = a*x + b*y</p>
<p>with error checking of types.</p>
<dl class="docutils">
<dt>z <span class="classifier-delimiter">:</span> <span class="classifier">Vector</span></dt>
<dd>The Vector that the result should be written to.</dd>
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">Scalar in the field of this space</span></dt>
<dd>Scalar to multiply <cite>x</cite> with.</dd>
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">Vector</span></dt>
<dd>The first of the summands</dd>
<dt>b <span class="classifier-delimiter">:</span> <span class="classifier">Scalar, optional</span></dt>
<dd>Scalar to multiply <cite>y</cite> with.</dd>
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">Vector, optional</span></dt>
<dd>The second of the summands</dd>
</dl>
<p>None</p>
<p>Some notes and examples</p>
<p>The vectors <cite>z</cite>, <cite>x</cite> and <cite>y</cite> may be aligned, thus a call</p>
<p>space.lincomb(x, 2, x, 3.14, x)</p>
<p>is (mathematically) equivalent to</p>
<p>x = x * (1 + 2 + 3.14)</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.space.LinearSpace.multiply">
<code class="descclassname">LinearSpace.</code><code class="descname">multiply</code><span class="sig-paren">(</span><em>z</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/space.html#LinearSpace.multiply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.space.LinearSpace.multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the pointwise product of x and y and assigns it to y
z = x * y</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.space.LinearSpace.norm">
<code class="descclassname">LinearSpace.</code><code class="descname">norm</code><span class="sig-paren">(</span><em>vector</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/space.html#LinearSpace.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.space.LinearSpace.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the norm of a vector.</p>
</dd></dl>

<dl class="method">
<dt id="odl.space.space.LinearSpace.zero">
<code class="descclassname">LinearSpace.</code><code class="descname">zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/odl/space/space.html#LinearSpace.zero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odl.space.space.LinearSpace.zero" title="Permalink to this definition">¶</a></dt>
<dd><p>A zero vector in this space.</p>
<p>The zero vector is defined as the additive unit of a space.</p>
<p>None</p>
<dl class="docutils">
<dt>v <span class="classifier-delimiter">:</span> <span class="classifier">Vector</span></dt>
<dd>The zero vector of this space</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-odl.space">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-odl.space" title="Permalink to this headline">¶</a></h2>
<p>Core Spaces and set support.</p>
<div class="section" id="abstract-and-concrete-sets-module-set">
<h3>Abstract and concrete sets (module &#8216;set&#8217;)<a class="headerlink" href="#abstract-and-concrete-sets-module-set" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Set</td>
<td>Base class for mathematical sets</td>
</tr>
<tr class="row-odd"><td>ComplexNumbers</td>
<td>Set of complex numbers</td>
</tr>
<tr class="row-even"><td>RealNumbers</td>
<td>Set of real numbers</td>
</tr>
<tr class="row-odd"><td>Integers</td>
<td>Set of integers</td>
</tr>
<tr class="row-even"><td>IntervalProd</td>
<td>Cartesian product of n intervals</td>
</tr>
<tr class="row-odd"><td>Interval</td>
<td>IntervalProd specialization in 1-D</td>
</tr>
<tr class="row-even"><td>Rectangle</td>
<td>IntervalProd specialization in 2-D</td>
</tr>
<tr class="row-odd"><td>Cube</td>
<td>IntervalProd specialization in 3-D</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="abstract-vector-spaces-modules-space-and-product">
<h3>Abstract vector spaces (modules &#8216;space&#8217; and &#8216;product&#8217;)<a class="headerlink" href="#abstract-vector-spaces-modules-space-and-product" title="Permalink to this headline">¶</a></h3>
<div class="section" id="general-spaces-module-space">
<h4>General Spaces (module &#8216;space&#8217;)<a class="headerlink" href="#general-spaces-module-space" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>LinearSpace</td>
<td>Vector space with addition and scalar multiplication</td>
</tr>
<tr class="row-odd"><td>MetricSpace</td>
<td>A LinearSpace with a metric</td>
</tr>
<tr class="row-even"><td>NormedSpace</td>
<td>A MetricSpace with a norm and induced metric</td>
</tr>
<tr class="row-odd"><td>HilbertSpace</td>
<td>A NormedSpace with an inner product and induced norm</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="product-spaces-module-product">
<h4>Product Spaces (module &#8216;product&#8217;)<a class="headerlink" href="#product-spaces-module-product" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>LinearProductSpace</td>
<td>Cartesian product of linear spaces</td>
</tr>
<tr class="row-odd"><td>MetricProductSpace</td>
<td>Cartesian product of metric spaces</td>
</tr>
<tr class="row-even"><td>NormedProductSpace</td>
<td>Cartesian product of normed spaces</td>
</tr>
<tr class="row-odd"><td>HilbertProductSpace</td>
<td>Cartesian product of Hilbert spaces</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="concrete-vector-spaces-modules-cartesian-cuda-function">
<h3>Concrete vector spaces (modules &#8216;cartesian&#8217;, &#8216;cuda&#8217;, &#8216;function&#8217;)<a class="headerlink" href="#concrete-vector-spaces-modules-cartesian-cuda-function" title="Permalink to this headline">¶</a></h3>
<div class="section" id="r-n-type-spaces-cpu-implementation-module-cartesian">
<h4>R^n type spaces, CPU implementation (module &#8216;cartesian&#8217;)<a class="headerlink" href="#r-n-type-spaces-cpu-implementation-module-cartesian" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="r-n-type-spaces-cuda-implementation-module-cuda">
<h4>R^n type spaces, CUDA implementation (module &#8216;cuda&#8217;)<a class="headerlink" href="#r-n-type-spaces-cuda-implementation-module-cuda" title="Permalink to this headline">¶</a></h4>
<p>Requires the compiled extension &#8216;odlpp&#8217;</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CudaRn</td>
<td>En implemented in CUDA</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="function-spaces-module-function">
<h4>Function spaces (module &#8216;function&#8217;)<a class="headerlink" href="#function-spaces-module-function" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>FunctionSpace</td>
<td>Vector space of functions over some domain</td>
</tr>
<tr class="row-odd"><td>L2</td>
<td>FunctionSpace with the usual integral 2-norm</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">odl.space package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-odl.space.cartesian">odl.space.cartesian module</a><ul>
<li><a class="reference internal" href="#list-of-classes">List of classes</a></li>
<li><a class="reference internal" href="#space-attributes-and-methods">Space attributes and methods</a></li>
<li><a class="reference internal" href="#vector-attributes-and-methods">Vector attributes and methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-odl.space.cuda">odl.space.cuda module</a></li>
<li><a class="reference internal" href="#module-odl.space.function">odl.space.function module</a></li>
<li><a class="reference internal" href="#module-odl.space.product">odl.space.product module</a></li>
<li><a class="reference internal" href="#module-odl.space.sequence">odl.space.sequence module</a></li>
<li><a class="reference internal" href="#module-odl.space.set">odl.space.set module</a></li>
<li><a class="reference internal" href="#module-odl.space.space">odl.space.space module</a><ul>
<li><a class="reference internal" href="#class-descriptions">Class descriptions</a></li>
<li><a class="reference internal" href="#see-also">See also</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-odl.space">Module contents</a><ul>
<li><a class="reference internal" href="#abstract-and-concrete-sets-module-set">Abstract and concrete sets (module &#8216;set&#8217;)</a></li>
<li><a class="reference internal" href="#abstract-vector-spaces-modules-space-and-product">Abstract vector spaces (modules &#8216;space&#8217; and &#8216;product&#8217;)</a><ul>
<li><a class="reference internal" href="#general-spaces-module-space">General Spaces (module &#8216;space&#8217;)</a></li>
<li><a class="reference internal" href="#product-spaces-module-product">Product Spaces (module &#8216;product&#8217;)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#concrete-vector-spaces-modules-cartesian-cuda-function">Concrete vector spaces (modules &#8216;cartesian&#8217;, &#8216;cuda&#8217;, &#8216;function&#8217;)</a><ul>
<li><a class="reference internal" href="#r-n-type-spaces-cpu-implementation-module-cartesian">R^n type spaces, CPU implementation (module &#8216;cartesian&#8217;)</a></li>
<li><a class="reference internal" href="#r-n-type-spaces-cuda-implementation-module-cuda">R^n type spaces, CUDA implementation (module &#8216;cuda&#8217;)</a></li>
<li><a class="reference internal" href="#function-spaces-module-function">Function spaces (module &#8216;function&#8217;)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/odl.space.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, Jonas Adler.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.6</a>
      
      |
      <a href="_sources/odl.space.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>